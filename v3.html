<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Fonksiyonlarda Yatay Doƒüru Testi - Bire Bir ve √ñrtenlik Analizi</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
            color: #333;
            line-height: 1.4;
            min-height: 100vh;
            padding: 10px;
            overflow-x: hidden;
        }

        .container {
            width: 100%;
            max-width: 800px;
            background-color: rgba(255, 255, 255, 0.98);
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            margin: 0 auto;
        }

        /* Desktop layout - iki s√ºtunlu */
        @media (min-width: 769px) {
            .container {
                max-width: 100%;
                width: 100%;
            }
            
            .content {
                display: flex;
                gap: 20px;
                align-items: flex-start;
            }
            
            .graph-container {
                flex: 1;
                min-width: 0;
            }
            
            .function-analysis {
                flex: 1;
                min-width: 0;
            }
        }

        header {
            background: linear-gradient(to right, #1a2a6c, #b21f1f);
            color: white;
            padding: 15px;
            text-align: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .logo {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 5px;
        }

        h1 {
            font-size: 1.2rem;
            margin: 0;
            line-height: 1.3;
        }

        .progress-info {
            font-size: 0.9rem;
            opacity: 0.9;
            margin-top: 5px;
        }

        .content {
            padding: 15px;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }

        .btn {
            padding: 15px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            touch-action: manipulation;
        }

        .btn:active {
            transform: scale(0.98);
        }

        .btn-primary {
            background: linear-gradient(135deg, #1a2a6c, #2d4aa7);
            color: white;
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
        }

        .btn-success:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .graph-container {
            background-color: #f8f9fa;
            padding: 5px;
            border-radius: 4px;
            text-align: center;
            margin-bottom: 5px;
            border: 1px solid #dee2e6;
        }

        .graph-header {
            margin-bottom: 15px;
        }

        .graph-header h3 {
            color: #1a2a6c;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            text-align: center;
            line-height: 1.3;
        }

        .canvas-wrapper {
            position: relative;
            width: 100%;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            margin: 0 auto;
            aspect-ratio: 1;
            border: 2px solid #dee2e6;
            overflow: hidden;
        }

        /* Desktop'ta grafik alanƒ±nƒ± optimize et */
        @media (min-width: 769px) {
            .canvas-wrapper {
                aspect-ratio: 1.2;
                max-height: 70vh;
            }
        }

        #functionChart {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }

        .function-analysis {
            background-color: #fff8e1;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #ff9800;
            position: relative;
            overflow: hidden;
        }

        .function-analysis h4 {
            color: #e65100;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1rem;
        }

        .analysis-container {
            background: #fff;
            border-radius: 8px;
            border: 2px solid #ffcc02;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .test-progress {
            padding: 15px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #28a745, #20c997);
            width: 0%;
            transition: width 0.3s ease;
        }

        .test-info {
            font-size: 14px;
            color: #495057;
            text-align: center;
        }

        .function-properties {
            padding: 20px;
        }

        .property-box {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #007bff;
            margin-bottom: 15px;
        }

        .property-box h5 {
            margin: 0 0 10px 0;
            color: #0056b3;
            font-size: 16px;
        }

        .property-box p {
            margin: 0;
            color: #495057;
            line-height: 1.5;
        }

        .analysis-result {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            margin: 5px 0;
            border-radius: 6px;
            font-weight: 500;
        }

        .result-success {
            background: rgba(40, 167, 69, 0.1);
            border: 1px solid #28a745;
            color: #155724;
        }

        .result-warning {
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid #ffc107;
            color: #856404;
        }

        .result-info {
            background: rgba(23, 162, 184, 0.1);
            border: 1px solid #17a2b8;
            color: #0c5460;
        }

        .horizontal-line {
            stroke: #ff6b6b;
            stroke-width: 2;
            stroke-dasharray: 5,5;
            opacity: 0.8;
        }

        .intersection-point {
            fill: #ff6b6b;
            stroke: #fff;
            stroke-width: 2;
        }

        .trend-icon {
            display: inline-block;
            margin-right: 5px;
            font-size: 14px;
        }

        /* Mobil optimizasyonlarƒ± */
        @media (max-width: 768px) {
            body {
                padding: 5px;
            }
            
            .container {
                border-radius: 5px;
                max-width: 800px;
            }
            
            .content {
                display: block;
            }
            
            header {
                padding: 10px;
            }
            
            h1 {
                font-size: 1rem;
            }
            
            .content {
                padding: 10px;
            }
            
            .graph-container {
                padding: 10px;
                margin-bottom: 15px;
            }
            
            .function-analysis {
                padding: 10px;
            }
            
            .property-box {
                padding: 10px;
                margin-bottom: 10px;
            }
            
            .property-box h5 {
                font-size: 14px;
            }
        }

        /* Landscape orientation */
        @media (orientation: landscape) and (max-height: 600px) {
            .canvas-wrapper {
                aspect-ratio: 4/3;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#FFD700" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 12h18m-9-9v18"></path>
                    <circle cx="12" cy="12" r="3"></circle>
                </svg>
                <h1>Fonksiyonlarda Yatay Doƒüru Testi - Bire Bir ve √ñrtenlik Analizi</h1>
            </div>
            <div class="progress-info" id="progressInfo">
                Fonksiyon: 0/10
            </div>
        </header>
        
        <div class="content">
            
            <div class="graph-container">
                <div class="graph-header" style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">

                    <div class="controls" style="margin: 0; flex-shrink: 0;">
                        <button class="btn btn-primary" id="generateBtn">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M12 2v20"></path>
                                <path d="M2 12h20"></path>
                            </svg>
                            Rastgele Fonksiyon √úret
                        </button>
                        <button class="btn btn-success" id="startTestBtn" style="display: none;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M5 3l14 9-14 9V3z"></path>
                            </svg>
                            Yatay Doƒüru Testi Ba≈ülat
                        </button>
                        <button class="btn btn-success" id="nextBtn" style="display: none;" disabled>
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M9 18l6-6-6-6"></path>
                            </svg>
                            Sonraki Fonksiyon
                        </button>
                    </div>
                </div>
                <div class="canvas-wrapper">
                    <canvas id="functionChart"></canvas>
                </div>
            </div>

            <div class="function-analysis">
                <h4>
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#e65100" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M9 12l2 2 4-4"></path>
                        <circle cx="12" cy="12" r="9"></circle>
                    </svg>
                    Yatay Doƒüru Testi & Fonksiyon Analizi
                </h4>
                <div class="analysis-container">
                    <div class="test-progress" id="testProgress" style="display: none;">
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill"></div>
                        </div>
                        <div class="test-info" id="testInfo">Yatay doƒüru testi hazƒ±rlanƒ±yor...</div>
                    </div>
                    
                    <div class="function-properties" id="functionProperties">
                        <div class="property-box">
                            <h5>üîç Fonksiyon Analizi</h5>
                            <p>Grafik √ßizildikten sonra yatay doƒüru testi ile fonksiyonun √∂zelliklerini analiz edeceƒüiz.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global deƒüi≈ükenler
        let currentPoints = [];
        let currentGraphType = '';
        let xIntercepts = [];
        let canvas, ctx;
        let animationId = null;
        let animationProgress = 0;
        let isAnimating = false;
        let animationSpeed = 0.01; // Daima yava≈ü animasyon
        let functionCounter = 0;
        let maxFunctions = 10;
        let isInteractiveMode = false;
        let interactiveFunctionCounter = 0;
        let maxInteractiveFunctions = 10;
        let isAnswerCorrect = false;
        let nextButtonEnabled = false;
        
        // Yatay doƒüru testi i√ßin deƒüi≈ükenler
        let isHorizontalLineTestActive = false;
        let horizontalLineY = 0;
        let testProgress = 0;
        let testAnimationId = null;
        let intersectionPoints = [];
        let testResults = {
            isOneToOne: false,
            isOnto: false,
            examples: []
        };
        
        // Sayfa y√ºklendiƒüinde ba≈ülat
        document.addEventListener('DOMContentLoaded', function() {
            canvas = document.getElementById('functionChart');
            ctx = canvas.getContext('2d');
            setupCanvas();
            setupEventListeners();
            updateProgressInfo();
            
            // ƒ∞lk grafik i√ßin bo≈ü √ßizim
            drawEmptyGraph();
        });
        
        // Event listener'larƒ± ayarla
        function setupEventListeners() {
            document.getElementById('generateBtn').addEventListener('click', generateRandomFunction);
            document.getElementById('startTestBtn').addEventListener('click', startHorizontalLineTest);
            document.getElementById('nextBtn').addEventListener('click', generateRandomFunction);
            window.addEventListener('resize', setupCanvas);
            
            // Touch event optimizasyonlarƒ± - sadece canvas i√ßin
            canvas.addEventListener('touchstart', function(e) {
                e.preventDefault();
            }, { passive: false });
            
            canvas.addEventListener('touchmove', function(e) {
                e.preventDefault();
            }, { passive: false });
        }
        
        // ƒ∞lerleme bilgisini g√ºncelle
        function updateProgressInfo() {
            const progressInfo = document.getElementById('progressInfo');
            const generateBtn = document.getElementById('generateBtn');
            const nextBtn = document.getElementById('nextBtn');
            
            if (!isInteractiveMode) {
                progressInfo.textContent = `Fonksiyon: ${functionCounter}/${maxFunctions}`;
                
                if (functionCounter >= maxFunctions) {
                    generateBtn.disabled = false;
                    generateBtn.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M9 12l2 2 4-4"></path>
                            <circle cx="12" cy="12" r="10"></circle>
                        </svg>
                        ƒ∞nteraktif Moda Ge√ß
                    `;
                    generateBtn.style.background = 'linear-gradient(135deg, #28a745, #20c997)';
                }
            } else {
                progressInfo.textContent = `ƒ∞nteraktif Mod: ${interactiveFunctionCounter}/${maxInteractiveFunctions}`;
                
                if (interactiveFunctionCounter >= maxInteractiveFunctions) {
                    generateBtn.style.display = 'none';
                    nextBtn.style.display = 'none';
                    
                    // Tamamlandƒ± mesajƒ± g√∂ster
                    const controls = document.querySelector('.controls');
                    controls.innerHTML = `
                        <div style="text-align: center; padding: 20px; background: #d4edda; border-radius: 8px; color: #155724;">
                            <h3>üéâ Tebrikler!</h3>
                            <p>T√ºm egzersizleri ba≈üarƒ±yla tamamladƒ±nƒ±z!</p>
                        </div>
                    `;
                } else {
                    generateBtn.style.display = 'none';
                    nextBtn.style.display = 'flex';
                    nextBtn.disabled = !nextButtonEnabled;
                }
            }
        }
        
        // Canvas boyutlarƒ±nƒ± ayarla
        function setupCanvas() {
            const canvasWrapper = document.querySelector('.canvas-wrapper');
            const width = canvasWrapper.clientWidth;
            const height = canvasWrapper.clientHeight;
            
            // Retina display desteƒüi
            const ratio = window.devicePixelRatio || 1;
            canvas.width = width * ratio;
            canvas.height = height * ratio;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            ctx.scale(ratio, ratio);
            
            if (currentPoints.length > 0) {
                if (isAnimating) {
                    drawCoordinateSystem();
                } else {
                    drawGraph();
                }
            } else {
                drawEmptyGraph();
            }
        }
        
        // Rastgele tam sayƒ± √ºret
        function randomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        
        // X eksenini kesen noktalar √ºret - GARANTƒ∞Lƒ∞ TAM SAYI ALGORƒ∞TMASI
        function generateXIntercepts() {
            const numIntercepts = randomInt(1, 3);
            const intercepts = [];
            const usedX = new Set();
            
            console.log(`üéØ Generating ${numIntercepts} X-intercept(s)...`);
            
            // TAM SAYI GARANTƒ∞Sƒ∞ ƒ∞LE X KESƒ∞M NOKTALARI √úRET
            let attempts = 0;
            while (intercepts.length < numIntercepts && attempts < 50) {
                const x = randomInt(-8, 8); // Mutlaka tam sayƒ± (-8 ile 8 arasƒ±)
                
                if (!usedX.has(x)) {
                    usedX.add(x);
                    intercepts.push(x);
                    console.log(`‚úÖ Generated X-intercept: ${x} (integer: ${Number.isInteger(x)})`);
                }
                attempts++;
            }
            
            // FINAL TAM SAYI KONTROL√ú
            intercepts.forEach(x => {
                if (!Number.isInteger(x)) {
                    console.error(`‚ùå CRITICAL ERROR: X-intercept is not integer! x = ${x}`);
                    throw new Error(`X-intercept must be integer: ${x}`);
                }
            });
            
            const sortedIntercepts = intercepts.sort((a, b) => a - b);
            console.log(`üéâ FINAL X-intercepts (all integers):`, sortedIntercepts);
            
            return sortedIntercepts;
        }
        
        // TAMAMEN YENƒ∞ ALGORƒ∞TMA: GER√áEK RASTGELE FONKSIYON √úRETƒ∞Mƒ∞ - TAM SAYI X KESƒ∞M GARANTƒ∞Sƒ∞
        function generatePointsFromIntercepts(intercepts) {
            console.log('üéØ GENERATING FUNCTION WITH INTERCEPTS:', intercepts);
            
            // TAM SAYI X KESƒ∞M NOKTALARI ZORUNLU KONTROL√ú
            intercepts.forEach(x => {
                if (!Number.isInteger(x)) {
                    console.error(`‚ö†Ô∏è FATAL: Non-integer X-intercept! x = ${x}`);
                    throw new Error(`X-intercept must be integer: ${x}`);
                }
            });
            
            // SIRA: X deƒüerlerine g√∂re sƒ±rala
            const sortedIntercepts = [...intercepts].sort((a, b) => a - b);
            console.log('‚úÖ Sorted integer X-intercepts:', sortedIntercepts);
            
            // ALGORƒ∞TMA: X kesim noktalarƒ±ndan dinamik fonksiyon olu≈ütur
            const points = [];
            
            // BA≈ûLANGI√á VE SON NOKTALARINI BELƒ∞RLE
            const minIntercept = sortedIntercepts[0];
            const maxIntercept = sortedIntercepts[sortedIntercepts.length - 1];
            
            // SOL BA≈ûLANGI√á NOKTASI (-8 ile minIntercept-2 arasƒ±) - Y deƒüeri 1-4 arasƒ±
            const leftStartX = randomInt(-8, minIntercept - 2);
            const leftStartY = (Math.random() < 0.5 ? 1 : -1) * randomInt(1, 4); // ¬±1 ile ¬±4 arasƒ±
            points.push({x: leftStartX, y: leftStartY});
            console.log(`üìç Left start: (${leftStartX}, ${leftStartY})`);
            
            // X KESƒ∞M NOKTALARI VE ARALARDA G√úVENLƒ∞ NOKTALAR
            sortedIntercepts.forEach((interceptX, index) => {
                // X kesim noktasƒ±nƒ± ekle
                points.push({x: interceptX, y: 0});
                console.log(`üéØ X-intercept: (${interceptX}, 0)`);
                
                // Eƒüer bu son intercept deƒüilse, arada bir nokta ekle
                if (index < sortedIntercepts.length - 1) {
                    const nextInterceptX = sortedIntercepts[index + 1];
                    const midX = Math.floor((interceptX + nextInterceptX) / 2);
                    
                    // ORTA NOKTA TAM SAYI OLACAK ≈ûEKƒ∞LDE AYARLA
                    const actualMidX = (midX === interceptX || midX === nextInterceptX) 
                        ? interceptX + 1 
                        : midX;
                    
                    // Y deƒüeri: i≈üaret deƒüi≈üimi i√ßin mutlaka pozitif veya negatif - SINIRLI
                    const midY = (Math.random() < 0.5 ? 1 : -1) * randomInt(1, 4); // ¬±1 ile ¬±4 arasƒ±
                    points.push({x: actualMidX, y: midY});
                    console.log(`üìå Mid point: (${actualMidX}, ${midY})`);
                }
            });
            
            // SAƒû SON NOKTA (maxIntercept+2 ile 10 arasƒ±) - Y deƒüeri 1-4 arasƒ±
            const rightEndX = randomInt(maxIntercept + 2, 10);
            const rightEndY = (Math.random() < 0.5 ? 1 : -1) * randomInt(1, 4); // ¬±1 ile ¬±4 arasƒ±
            points.push({x: rightEndX, y: rightEndY});
            console.log(`üìç Right end: (${rightEndX}, ${rightEndY})`);
            
            // X'E G√ñRE SIRALA
            points.sort((a, b) => a.x - b.x);
            
            // SABƒ∞T ARALIK KONTROL√ú VE D√úZELTME
            for (let i = 0; i < points.length - 1; i++) {
                const p1 = points[i];
                const p2 = points[i + 1];
                
                const deltaY = Math.abs(p2.y - p1.y);
                const deltaX = Math.abs(p2.x - p1.x);
                
                // Eƒüer eƒüim √ßok d√º≈ü√ºkse (sabit gibi g√∂r√ºnebilir)
                if (deltaY < 1 && deltaX > 1) {
                    console.warn(`üîß FIXING LOW SLOPE: [${p1.x}, ${p2.x}] deltaY=${deltaY}`);
                    
                    // Y deƒüerini daha belirgin yap - ama sƒ±nƒ±rlƒ± tut
                    if (p2.y !== 0) { // X-intercept deƒüilse deƒüi≈ütir
                        p2.y = p2.y > 0 ? Math.max(2, Math.min(4, p2.y)) : Math.min(-2, Math.max(-4, p2.y));
                        console.log(`üîß Fixed point: (${p2.x}, ${p2.y})`);
                    } else if (p1.y !== 0) { // √ñnceki nokta X-intercept deƒüilse
                        p1.y = p1.y > 0 ? Math.max(2, Math.min(4, p1.y)) : Math.min(-2, Math.max(-4, p1.y));
                        console.log(`üîß Fixed point: (${p1.x}, ${p1.y})`);
                    }
                }
            }
            
            // GLOBAL G√úNCELLEME
            xIntercepts = sortedIntercepts;
            
            // FINAL KONTROL√ú
            console.log('üéâ GENERATED POINTS:', points);
            console.log('üéØ CONFIRMED X-INTERCEPTS:', xIntercepts);
            
            // TAM SAYI DOUBLE-CHECK
            points.forEach(p => {
                if (!Number.isInteger(p.x)) {
                    console.error(`‚ùå CRITICAL: Non-integer X coordinate! (${p.x}, ${p.y})`);
                    throw new Error(`All X coordinates must be integers: (${p.x}, ${p.y})`);
                }
            });
            
            // Y DEƒûERLERƒ∞ KONTROL - ETIKET UYUMU ƒ∞√áƒ∞N
            points.forEach(p => {
                if (Math.abs(p.y) > 5) {
                    console.warn(`‚ö†Ô∏è Y value might overlap with labels: (${p.x}, ${p.y})`);
                }
            });
            
            console.log('‚úÖ ALL COORDINATES VALIDATED - INTEGERS ONLY, Y VALUES LIMITED');
            
            return points;
        }
        
        // Rastgele fonksiyon √ºret
        function generateRandomFunction() {
            if (!isInteractiveMode && functionCounter >= maxFunctions) {
                // ƒ∞nteraktif moda ge√ß
                isInteractiveMode = true;
                interactiveFunctionCounter = 0;
                updateProgressInfo();
                generateInteractiveFunction();
                return;
            }
            
            if (isInteractiveMode && interactiveFunctionCounter >= maxInteractiveFunctions) return;
            
            if (isInteractiveMode) {
                generateInteractiveFunction();
                return;
            }
            
            stopAnimation();
            stopHorizontalLineTest();
            
            functionCounter++;
            updateProgressInfo();
            
            xIntercepts = generateXIntercepts();
            currentPoints = generatePointsFromIntercepts(xIntercepts);
            currentGraphType = 'continuous'; // Daima s√ºrekli fonksiyon
            
            updateGraphTitle();
            resetAnalysis();
            
            startDrawAnimation();
        }
        
        // Animasyon ba≈ülatma
        function startDrawAnimation() {
            animationProgress = 0;
            isAnimating = true;
            currentAnalysisIndex = 0;
            
            drawCoordinateSystem();
            animateDrawing();
        }
        
        // Animasyonu durdurma
        function stopAnimation() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            isAnimating = false;
            animationProgress = 1;
            
            if (currentPoints.length > 0) {
                drawGraph();
                showTestButton();
            }
        }
        
        // √áizim animasyonu
        function animateDrawing() {
            if (!isAnimating) return;
            
            animationProgress += animationSpeed;
            
            if (animationProgress >= 1) {
                animationProgress = 1;
                isAnimating = false;
                showTestButton();
            }
            
            drawCoordinateSystem();
            drawAnimatedContinuousGraph();
            drawAnimatedPoints();
            
            if (isAnimating) {
                animationId = requestAnimationFrame(animateDrawing);
            }
        }
        
        // Koordinat sistemini √ßiz
        function drawCoordinateSystem() {
            const width = canvas.style.width ? parseInt(canvas.style.width) : canvas.width;
            const height = canvas.style.height ? parseInt(canvas.style.height) : canvas.height;
            
            const padding = Math.min(width, height) * 0.1;
            const centerX = width / 2;
            const centerY = height / 2;
            // D√úZELTME: X ve Y i√ßin ayrƒ± scale hesaplama - toplam 22 birim i√ßin (-11 ile +11 arasƒ±)
            const availableWidth = width - padding * 2;
            const availableHeight = height - padding * 2;
            const scaleX = availableWidth / 22; // X ekseni i√ßin scale
            const scaleY = availableHeight / 22; // Y ekseni i√ßin scale
            
            ctx.clearRect(0, 0, width, height);
            
            // Grid √ßizgileri √ßiz (ana eksenlerden √∂nce)
            // Mobil optimizasyonu - ekran boyutuna g√∂re grid ayarlarƒ±
            const isMobile = width < 500; // Mobil tespit
            
            // Mobilde daha belirgin grid i√ßin ayarlar
            if (isMobile) {
                ctx.strokeStyle = '#e8e8e8'; // Daha koyu gri
                ctx.lineWidth = 0.8; // Daha kalƒ±n √ßizgi
                ctx.globalAlpha = 0.7; // Daha opak
            } else {
                ctx.strokeStyle = '#e0e0e0'; // Masa√ºst√º i√ßin normal
                ctx.lineWidth = 0.5;
                ctx.globalAlpha = 0.6;
            }
            
            // Dikey grid √ßizgileri
            for (let i = -11; i <= 11; i++) {
                if (i === 0) continue; // Ana Y ekseni atlanacak
                const x = centerX + i * scaleX;
                if (x >= padding && x <= width - padding) {
                    ctx.beginPath();
                    ctx.moveTo(x, padding);
                    ctx.lineTo(x, height - padding);
                    ctx.stroke();
                }
            }
            
            // Yatay grid √ßizgileri
            for (let i = -11; i <= 11; i++) {
                if (i === 0) continue; // Ana X ekseni atlanacak
                const y = centerY - i * scaleY;
                if (y >= padding && y <= height - padding) {
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(width - padding, y);
                    ctx.stroke();
                }
            }
            
            // Grid √ßizimi tamamlandƒ±ktan sonra alpha'yƒ± sƒ±fƒ±rla
            ctx.globalAlpha = 1;
            
            // X ekseni (ana)
            ctx.beginPath();
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.moveTo(padding, centerY);
            ctx.lineTo(width - padding, centerY);
            ctx.stroke();
            
            // Y ekseni (ana)
            ctx.beginPath();
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 2;
            ctx.moveTo(centerX, height - padding);
            ctx.lineTo(centerX, padding);
            ctx.stroke();
            
            // Ok i≈üaretleri
            const arrowSize = Math.min(scaleX, scaleY) * 0.4;
            
            // X ekseni saƒü ok
            ctx.beginPath();
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            const xArrowTip = width - padding;
            ctx.moveTo(xArrowTip - arrowSize, centerY - arrowSize/2);
            ctx.lineTo(xArrowTip, centerY);
            ctx.lineTo(xArrowTip - arrowSize, centerY + arrowSize/2);
            ctx.stroke();
            
            // X ekseni sol ok
            ctx.beginPath();
            const xArrowLeftTip = padding;
            ctx.moveTo(xArrowLeftTip + arrowSize, centerY - arrowSize/2);
            ctx.lineTo(xArrowLeftTip, centerY);
            ctx.lineTo(xArrowLeftTip + arrowSize, centerY + arrowSize/2);
            ctx.stroke();
            
            // Y ekseni yukarƒ± ok
            ctx.beginPath();
            ctx.strokeStyle = '#2c3e50';
            const yArrowTip = padding;
            ctx.moveTo(centerX - arrowSize/2, yArrowTip + arrowSize);
            ctx.lineTo(centerX, yArrowTip);
            ctx.lineTo(centerX + arrowSize/2, yArrowTip + arrowSize);
            ctx.stroke();
            
            // Y ekseni a≈üaƒüƒ± ok
            ctx.beginPath();
            const yArrowBottomTip = height - padding;
            ctx.moveTo(centerX - arrowSize/2, yArrowBottomTip - arrowSize);
            ctx.lineTo(centerX, yArrowBottomTip);
            ctx.lineTo(centerX + arrowSize/2, yArrowBottomTip - arrowSize);
            ctx.stroke();
            
            // Eksen noktalarƒ±
            ctx.fillStyle = '#2c3e50';
            for (let i = -11; i <= 11; i++) {
                if (i === 0) continue;
                const x = centerX + i * scaleX;
                if (x >= padding && x <= width - padding) {
                    ctx.beginPath();
                    ctx.arc(x, centerY, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            for (let i = -11; i <= 11; i++) {
                if (i === 0) continue;
                const y = centerY - i * scaleY;
                if (y >= padding && y <= height - padding) {
                    ctx.beginPath();
                    ctx.arc(centerX, y, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Mobil i√ßin daha k√º√ß√ºk etiketler
            const fontSize = Math.max(8, Math.min(12, width * 0.025));
            ctx.fillStyle = '#2c3e50';
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = 'center';
            
            // X ekseni etiketleri - 1'den 11'e kadar ardƒ±≈üƒ±k
            for (let i = 1; i <= 11; i++) {
                const x = centerX + i * scaleX;
                if (x >= padding && x <= width - padding) {
                    ctx.fillText(i.toString(), x, centerY + fontSize + 3);
                }
            }
            
            // X ekseni negatif etiketler
            for (let i = -11; i <= -1; i++) {
                const x = centerX + i * scaleX;
                if (x >= padding && x <= width - padding) {
                    ctx.fillText(i.toString(), x, centerY + fontSize + 3);
                }
            }
            
            // Y ekseni etiketleri - 1'den 11'e kadar ardƒ±≈üƒ±k
            ctx.textAlign = 'right';
            for (let i = 1; i <= 11; i++) {
                const y = centerY - i * scaleY;
                if (y >= padding && y <= height - padding) {
                    ctx.fillText(i.toString(), centerX - 5, y + fontSize/3);
                }
            }
            
            // Y ekseni negatif etiketler
            for (let i = -11; i <= -1; i++) {
                const y = centerY - i * scaleY;
                if (y >= padding && y <= height - padding) {
                    ctx.fillText(i.toString(), centerX - 5, y + fontSize/3);
                }
            }
            
            // Orijin "0" etiketi - sabit 14px font boyutu
            ctx.font = 'bold 14px Arial';
            ctx.fillText('0', centerX + 14, centerY +16);
            
            // Eksen isimleri
            ctx.font = `bold ${fontSize + 2}px Arial`;
            ctx.fillStyle = '#1a2a6c';
            ctx.textAlign = 'center';
            ctx.fillText('x', width - padding + fontSize, centerY - 5);
            ctx.fillText('y', centerX + fontSize, padding - 5);
        }
        
        // Koordinat d√∂n√º≈ü√ºm fonksiyonlarƒ±
        function toCanvasX(x) {
            const width = canvas.style.width ? parseInt(canvas.style.width) : canvas.width;
            const height = canvas.style.height ? parseInt(canvas.style.height) : canvas.height;
            
            const padding = Math.min(width, height) * 0.1;
            
            // D√úZELTME: X ekseni i√ßin sadece geni≈ülik kullan - toplam 22 birim i√ßin
            const availableWidth = width - padding * 2;
            const scaleX = availableWidth / 22; // Toplam 22 birim (-11 ile +11 arasƒ±)
            return width / 2 + x * scaleX;
        }
        
        function toCanvasY(y) {
            const width = canvas.style.width ? parseInt(canvas.style.width) : canvas.width;
            const height = canvas.style.height ? parseInt(canvas.style.height) : canvas.height;
            
            const padding = Math.min(width, height) * 0.1;
            
            // D√úZELTME: Y ekseni i√ßin sadece y√ºkseklik kullan - toplam 22 birim i√ßin
            const availableHeight = height - padding * 2;
            const scaleY = availableHeight / 22; // Toplam 22 birim (-11 ile +11 arasƒ±)
            return height / 2 - y * scaleY;
        }
        
        // Segment rengini belirle - her zaman kƒ±rmƒ±zƒ±
        function getSegmentColor(startPoint, endPoint) {
            return '#dc3545'; // T√ºm segmentler kƒ±rmƒ±zƒ±
        }

        // Animasyonlu s√ºrekli grafik √ßizimi
        function drawAnimatedContinuousGraph() {
            if (currentPoints.length === 0) return;
            
            const minX = Math.min(...currentPoints.map(p => p.x));
            const maxX = Math.max(...currentPoints.map(p => p.x));
            const currentMaxX = minX + (maxX - minX) * animationProgress;
            
            ctx.lineWidth = 3;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 2;
            ctx.shadowOffsetX = 1;
            ctx.shadowOffsetY = 1;
            
            for (let i = 1; i < currentPoints.length; i++) {
                const prev = currentPoints[i-1];
                const current = currentPoints[i];
                
                if (prev.x > currentMaxX) break;
                
                let endPoint = current;
                if (current.x > currentMaxX) {
                    const t = (currentMaxX - prev.x) / (current.x - prev.x);
                    endPoint = {
                        x: prev.x + t * (current.x - prev.x),
                        y: prev.y + t * (current.y - prev.y)
                    };
                }
                
                // Segment rengini belirle
                ctx.strokeStyle = getSegmentColor(prev, endPoint);
                
                ctx.beginPath();
                ctx.moveTo(toCanvasX(prev.x), toCanvasY(prev.y));
                
                // Geli≈ütirilmi≈ü nokta algƒ±lama ve yumu≈üak eƒüri √ßizimi
                const isNearZero = Math.abs(prev.y) < 0.6 || Math.abs(endPoint.y) < 0.6;
                
                // Standart Bezier eƒürisi
                let smoothness = 0.5; // Sabit yumu≈üaklƒ±k deƒüeri
                
                const cp1x = toCanvasX(prev.x + (endPoint.x - prev.x) * smoothness);
                const cp1y = toCanvasY(prev.y);
                const cp2x = toCanvasX(prev.x + (endPoint.x - prev.x) * (1 - smoothness));
                const cp2y = toCanvasY(endPoint.y);
                
                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, toCanvasX(endPoint.x), toCanvasY(endPoint.y));
                ctx.stroke();
                
                if (current.x > currentMaxX) break;
            }
            
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }
        
        // Animasyonlu nokta √ßizimi - X kesim noktalarƒ± + Tanƒ±m k√ºmesi u√ß noktalarƒ±
        function drawAnimatedPoints() {
            if (currentPoints.length === 0) return;
            
            const minX = Math.min(...currentPoints.map(p => p.x));
            const maxX = Math.max(...currentPoints.map(p => p.x));
            const currentMaxX = minX + (maxX - minX) * animationProgress;
            
            // X kesim noktalarƒ±nƒ± √ßiz - kƒ±rmƒ±zƒ± √ßemberler
            xIntercepts.forEach(x => {
                if (x <= currentMaxX) {
                    const cx = toCanvasX(x);
                    const cy = toCanvasY(0);
                    
                    // G√∂lge efekti
                    ctx.beginPath();
                    ctx.fillStyle = 'rgba(220, 53, 69, 0.3)';
                    ctx.arc(cx + 1, cy + 1, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Dƒ±≈ü √ßember (beyaz kenarlƒ±k)
                    ctx.beginPath();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.arc(cx, cy, 5, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // ƒ∞√ß √ßember (kƒ±rmƒ±zƒ±)
                    ctx.beginPath();
                    ctx.fillStyle = '#dc3545';
                    ctx.arc(cx, cy, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // TANƒ∞M K√úMESƒ∞ U√á NOKTALARI - mavi √ßemberler
            if (currentPoints.length > 0) {
                const sortedPoints = [...currentPoints].sort((a, b) => a.x - b.x);
                const leftEndpoint = sortedPoints[0];
                const rightEndpoint = sortedPoints[sortedPoints.length - 1];
                
                // Sol u√ß nokta
                if (leftEndpoint.x <= currentMaxX) {
                    const cx = toCanvasX(leftEndpoint.x);
                    const cy = toCanvasY(leftEndpoint.y);
                    
                    // G√∂lge efekti
                    ctx.beginPath();
                    ctx.fillStyle = 'rgba(52, 144, 220, 0.3)';
                    ctx.arc(cx + 1, cy + 1, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Dƒ±≈ü √ßember (beyaz kenarlƒ±k)
                    ctx.beginPath();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1.5;
                    ctx.arc(cx, cy, 4, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // ƒ∞√ß √ßember (mavi)
                    ctx.beginPath();
                    ctx.fillStyle = '#3490dc';
                    ctx.arc(cx, cy, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Saƒü u√ß nokta (sol u√ßtan farklƒ±ysa)
                if (rightEndpoint.x !== leftEndpoint.x && rightEndpoint.x <= currentMaxX) {
                    const cx = toCanvasX(rightEndpoint.x);
                    const cy = toCanvasY(rightEndpoint.y);
                    
                    // G√∂lge efekti
                    ctx.beginPath();
                    ctx.fillStyle = 'rgba(52, 144, 220, 0.3)';
                    ctx.arc(cx + 1, cy + 1, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Dƒ±≈ü √ßember (beyaz kenarlƒ±k)
                    ctx.beginPath();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1.5;
                    ctx.arc(cx, cy, 4, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // ƒ∞√ß √ßember (mavi)
                    ctx.beginPath();
                    ctx.fillStyle = '#3490dc';
                    ctx.arc(cx, cy, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        // Normal grafik √ßizimi (animasyonsuz)
        function drawGraph() {
            drawCoordinateSystem();
            drawContinuousGraph();
            drawPoints(); // drawXIntercepts kaldƒ±rƒ±ldƒ± - drawPoints zaten X kesim noktalarƒ±nƒ± √ßiziyor
        }
        
        // S√ºrekli grafik √ßiz
        function drawContinuousGraph() {
            if (currentPoints.length === 0) return;
            
            ctx.lineWidth = 3;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 2;
            ctx.shadowOffsetX = 1;
            ctx.shadowOffsetY = 1;
            
            for (let i = 1; i < currentPoints.length; i++) {
                const prev = currentPoints[i-1];
                const current = currentPoints[i];
                
                // Segment rengini belirle
                ctx.strokeStyle = getSegmentColor(prev, current);
                
                ctx.beginPath();
                ctx.moveTo(toCanvasX(prev.x), toCanvasY(prev.y));
                
                // Geli≈ütirilmi≈ü nokta algƒ±lama ve yumu≈üak eƒüri √ßizimi
                const isNearZero = Math.abs(prev.y) < 0.6 || Math.abs(current.y) < 0.6;
                
                // Standart Bezier eƒürisi
                let smoothness = 0.5; // Sabit yumu≈üaklƒ±k deƒüeri
                
                const cp1x = toCanvasX(prev.x + (current.x - prev.x) * smoothness);
                const cp1y = toCanvasY(prev.y);
                const cp2x = toCanvasX(prev.x + (current.x - prev.x) * (1 - smoothness));
                const cp2y = toCanvasY(current.y);
                
                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, toCanvasX(current.x), toCanvasY(current.y));
                ctx.stroke();
            }
            
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }
        
        // X kesim noktalarƒ±nƒ± √ßiz - gereksiz fonksiyon (drawPoints zaten yapƒ±yor)
        function drawXIntercepts() {
            // Bu fonksiyon artƒ±k kullanƒ±lmƒ±yor - drawPoints() ve drawAnimatedPoints() 
            // zaten X kesim noktalarƒ±nƒ± √ßiziyor
        }
        
        // Noktalarƒ± √ßiz - X kesim noktalarƒ± + Tanƒ±m k√ºmesi u√ß noktalarƒ±
        function drawPoints() {
            // X kesim noktalarƒ±nƒ± √ßiz - kƒ±rmƒ±zƒ± √ßemberler
            xIntercepts.forEach(x => {
                const cx = toCanvasX(x);
                const cy = toCanvasY(0);
                
                // G√∂lge efekti
                ctx.beginPath();
                ctx.fillStyle = 'rgba(220, 53, 69, 0.3)';
                ctx.arc(cx + 1, cy + 1, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Dƒ±≈ü √ßember (beyaz kenarlƒ±k)
                ctx.beginPath();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.arc(cx, cy, 5, 0, Math.PI * 2);
                ctx.stroke();
                
                // ƒ∞√ß √ßember (kƒ±rmƒ±zƒ±)
                ctx.beginPath();
                ctx.fillStyle = '#dc3545';
                ctx.arc(cx, cy, 5, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // TANƒ∞M K√úMESƒ∞ U√á NOKTALARI - mavi √ßemberler
            if (currentPoints.length > 0) {
                const sortedPoints = [...currentPoints].sort((a, b) => a.x - b.x);
                const leftEndpoint = sortedPoints[0];
                const rightEndpoint = sortedPoints[sortedPoints.length - 1];
                
                // Sol u√ß nokta
                const leftCx = toCanvasX(leftEndpoint.x);
                const leftCy = toCanvasY(leftEndpoint.y);
                
                // G√∂lge efekti
                ctx.beginPath();
                ctx.fillStyle = 'rgba(52, 144, 220, 0.3)';
                ctx.arc(leftCx + 1, leftCy + 1, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Dƒ±≈ü √ßember (beyaz kenarlƒ±k)
                ctx.beginPath();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1.5;
                ctx.arc(leftCx, leftCy, 4, 0, Math.PI * 2);
                ctx.stroke();
                
                // ƒ∞√ß √ßember (mavi)
                ctx.beginPath();
                ctx.fillStyle = '#3490dc';
                ctx.arc(leftCx, leftCy, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Saƒü u√ß nokta (sol u√ßtan farklƒ±ysa)
                if (rightEndpoint.x !== leftEndpoint.x) {
                    const rightCx = toCanvasX(rightEndpoint.x);
                    const rightCy = toCanvasY(rightEndpoint.y);
                    
                    // G√∂lge efekti
                    ctx.beginPath();
                    ctx.fillStyle = 'rgba(52, 144, 220, 0.3)';
                    ctx.arc(rightCx + 1, rightCy + 1, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Dƒ±≈ü √ßember (beyaz kenarlƒ±k)
                    ctx.beginPath();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1.5;
                    ctx.arc(rightCx, rightCy, 4, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // ƒ∞√ß √ßember (mavi)
                    ctx.beginPath();
                    ctx.fillStyle = '#3490dc';
                    ctx.arc(rightCx, rightCy, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        // Bo≈ü grafik √ßiz
        function drawEmptyGraph() {
            drawCoordinateSystem();
        }
        
        // Grafik ba≈ülƒ±ƒüƒ±nƒ± g√ºncelle
        function updateGraphTitle() {
            const graphTitleElement = document.getElementById('graphTitle');
            if (!graphTitleElement) {
                // Element yoksa hi√ßbir ≈üey yapma
                return;
            }
            
            let titleText = '';
            if (!isInteractiveMode) {
                titleText = ``; // Bo≈ü ba≈ülƒ±k
            } else {
                const modeText = interactiveFunctionCounter > 5 ? 'Aralƒ±k Yazma' : 'Artan/Azalan Se√ßme';
                titleText = `ƒ∞nteraktif Egzersiz #${interactiveFunctionCounter} - ${modeText}`;
            }
            
            graphTitleElement.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#1a2a6c" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 3v18h18"></path>
                    <path d="M19 9l-5 5-4-4-3 3"></path>
                </svg>
                ${titleText}
            `;
        }

        // ƒ∞≈üaret tablosu analizi i√ßin veri hazƒ±rlama
        function prepareSignTableAnalysis() {
            monotonicityData = [];
            criticalPoints = [];
            
            if (currentPoints.length < 2) return;
            
            // X eksenini kesen noktalarƒ± (k√∂kler) belirle
            const roots = xIntercepts.sort((a, b) => a - b);
            console.log('X-intercepts (roots):', roots);
            
            // Tanƒ±m aralƒ±ƒüƒ±nƒ± belirle
            const allXValues = currentPoints.map(p => p.x);
            const domainStart = Math.min(...allXValues);
            const domainEnd = Math.max(...allXValues);
            
            // Sƒ±nƒ±r noktalarƒ±: ba≈ülangƒ±√ß, k√∂kler, son
            const boundaries = [domainStart, ...roots, domainEnd].sort((a, b) => a - b);
            
            // Her aralƒ±k i√ßin i≈üaret analizi
            for (let i = 0; i < boundaries.length - 1; i++) {
                const startX = boundaries[i];
                const endX = boundaries[i + 1];
                
                // Aralƒ±ƒüƒ±n ortasƒ±ndaki noktada fonksiyonun deƒüerini hesapla
                const midX = (startX + endX) / 2;
                const midY = calculateFunctionValue(midX);
                
                let status = '';
                let statusText = '';
                let statusSymbol = '';
                
                if (midY > 0.01) { // K√º√ß√ºk pozitif deƒüerleri de pozitif say
                    status = 'positive';
                    statusText = 'POZƒ∞Tƒ∞F';
                    statusSymbol = '+';
                } else if (midY < -0.01) { // K√º√ß√ºk negatif deƒüerleri de negatif say
                    status = 'negative';
                    statusText = 'NEGATƒ∞F';
                    statusSymbol = '‚àí';
                } else {
                    status = 'zero';
                    statusText = 'SIFIR';
                    statusSymbol = '0';
                }
                
                monotonicityData.push({
                    startX: startX,
                    endX: endX,
                    interval: `(${startX}, ${endX})`,
                    status: status,
                    statusText: statusText,
                    statusSymbol: statusSymbol,
                    midY: midY.toFixed(2)
                });
            }
            
            console.log('Sign analysis data:', monotonicityData);
        }
        
        // Verilen x deƒüerinde fonksiyonun deƒüerini hesapla (interpolasyon)
        function calculateFunctionValue(x) {
            // Eƒüer x tam olarak bir nokta √ºzerindeyse
            for (const point of currentPoints) {
                if (Math.abs(point.x - x) < 0.001) {
                    return point.y;
                }
            }
            
            // Linear interpolasyon kullan
            const sortedPoints = [...currentPoints].sort((a, b) => a.x - b.x);
            
            for (let i = 0; i < sortedPoints.length - 1; i++) {
                const p1 = sortedPoints[i];
                const p2 = sortedPoints[i + 1];
                
                if (x >= p1.x && x <= p2.x) {
                    const t = (x - p1.x) / (p2.x - p1.x);
                    return p1.y + t * (p2.y - p1.y);
                }
            }
            
            // Aralƒ±k dƒ±≈üƒ±ndaysa en yakƒ±n deƒüeri d√∂nd√ºr
            if (x < sortedPoints[0].x) {
                return sortedPoints[0].y;
            } else {
                return sortedPoints[sortedPoints.length - 1].y;
            }
        }

        // ƒ∞≈üaret tablosunu sƒ±fƒ±rla
        function resetMonotonicityTable() {
            const tableBody = document.getElementById('monotonicityTableBody');
            
            if (isInteractiveMode) {
                tableBody.innerHTML = `
                    <tr>
                        <td colspan="100%" style="text-align: center; padding: 15px; color: #666;">
                            Grafik √ßizimi tamamlandƒ±ktan sonra interaktif i≈üaret tablosu burada g√∂r√ºnt√ºlenecektir...
                        </td>
                    </tr>
                `;
            } else {
                tableBody.innerHTML = `
                    <tr>
                        <td colspan="100%" style="text-align: center; padding: 15px; color: #666;">
                            ƒ∞≈üaret tablosu analizi ba≈ülƒ±yor...
                        </td>
                    </tr>
                `;
            }
            
            const progressIndicator = document.getElementById('tableProgressIndicator');
            progressIndicator.style.width = '0%';
            
            const analysisSummary = document.getElementById('analysisSummary');
            analysisSummary.innerHTML = ''; // Analiz √∂zeti kaldƒ±rƒ±ldƒ±
            
            // Aralƒ±k analizini gizle
            const intervalAnalysis = document.getElementById('intervalAnalysis');
            intervalAnalysis.style.display = 'none';
        }

        // Animasyonla senkronize tablo g√ºncelleme
        function updateMonotonicityTableWithAnimation() {
            if (monotonicityData.length === 0) return;
            
            const minX = Math.min(...currentPoints.map(p => p.x));
            const maxX = Math.max(...currentPoints.map(p => p.x));
            const currentMaxX = minX + (maxX - minX) * animationProgress;
            
            // Hangi aralƒ±klarƒ±n g√∂sterilmesi gerektiƒüini belirle
            const visibleIntervals = monotonicityData.filter(data => data.startX <= currentMaxX);
            
            if (visibleIntervals.length > 0 && visibleIntervals.length !== currentAnalysisIndex) {
                const tableBody = document.getElementById('monotonicityTableBody');
                
                // Tablo i√ßeriƒüini temizle
                tableBody.innerHTML = '';
                
                // Aralƒ±k satƒ±rƒ±nƒ± olu≈ütur
                const intervalRow = document.createElement('tr');
                intervalRow.className = 'animated-row';
                
                // Durum satƒ±rƒ±nƒ± olu≈ütur
                const statusRow = document.createElement('tr');
                statusRow.className = 'animated-row';
                
                visibleIntervals.forEach((data, index) => {
                    // Aralƒ±k h√ºcresi
                    const intervalCell = document.createElement('td');
                    intervalCell.className = 'interval-row';
                    intervalCell.textContent = data.interval;
                    intervalRow.appendChild(intervalCell);
                    
                    // ƒ∞≈üaret h√ºcresi
                    const statusCell = document.createElement('td');
                    statusCell.className = `status-row ${data.status}`;
                    statusCell.textContent = data.statusSymbol;
                    statusRow.appendChild(statusCell);
                });
                
                tableBody.appendChild(intervalRow);
                tableBody.appendChild(statusRow);
                
                currentAnalysisIndex = visibleIntervals.length;
                updateSignAnalysisSummary(visibleIntervals);
            }
            
            // Progress indicator g√ºncelle
            const progressIndicator = document.getElementById('tableProgressIndicator');
            progressIndicator.style.width = (animationProgress * 100) + '%';
        }

        // Tabloyu tamamla - ƒ∞≈üaret Tablosu
        function completeMonotonicityTable() {
            if (monotonicityData.length === 0) return;
            
            currentAnalysisIndex = monotonicityData.length;
            
            const tableBody = document.getElementById('monotonicityTableBody');
            tableBody.innerHTML = '';
            
            // Sƒ±nƒ±r noktalarƒ±nƒ± ve k√∂kleri birle≈ütir
            const allXValues = currentPoints.map(p => p.x);
            const domainStart = Math.min(...allXValues);
            const domainEnd = Math.max(...allXValues);
            const roots = xIntercepts.sort((a, b) => a - b);
            const boundaries = [domainStart, ...roots, domainEnd].sort((a, b) => a - b);
            
            // X satƒ±rƒ±nƒ± olu≈ütur
            const xRow = document.createElement('tr');
            
            // Sol etiket h√ºcresi - "x"
            const xLabelCell = document.createElement('td');
            xLabelCell.textContent = 'x';
            xLabelCell.style.backgroundColor = '#2c3e50';
            xLabelCell.style.color = 'white';
            xLabelCell.style.fontWeight = 'bold';
            xLabelCell.style.fontSize = '14px';
            xLabelCell.style.padding = '8px 6px';
            xLabelCell.style.textAlign = 'center';
            xLabelCell.style.minWidth = '50px';
            xRow.appendChild(xLabelCell);
            
            // -‚àû h√ºcresi
            const minusInfCell = document.createElement('td');
            minusInfCell.textContent = '-‚àû';
            minusInfCell.className = 'hatched';
            xRow.appendChild(minusInfCell);
            
            // Sƒ±nƒ±r noktalarƒ± ve aralƒ±klar
            for (let i = 0; i < boundaries.length; i++) {
                const boundary = boundaries[i];
                const isRoot = roots.includes(boundary);
                
                // Sƒ±nƒ±r noktasƒ± h√ºcresi
                const boundaryCell = document.createElement('td');
                boundaryCell.textContent = boundary.toString();
                boundaryCell.className = isRoot ? 'root-cell-x' : 'boundary-cell-x';
                xRow.appendChild(boundaryCell);
                
                // Aralƒ±k h√ºcresi (son sƒ±nƒ±r hari√ß)
                if (i < boundaries.length - 1) {
                    const intervalCell = document.createElement('td');
                    intervalCell.textContent = `(${boundary}, ${boundaries[i + 1]})`;
                    intervalCell.style.backgroundColor = '#f8f9fa';
                    intervalCell.style.fontSize = '11px';
                    intervalCell.style.padding = '4px 2px';
                    xRow.appendChild(intervalCell);
                }
            }
            
            // +‚àû h√ºcresi
            const plusInfCell = document.createElement('td');
            plusInfCell.textContent = '+‚àû';
            plusInfCell.className = 'hatched';
            xRow.appendChild(plusInfCell);
            
            // f(x) satƒ±rƒ±nƒ± olu≈ütur
            const fxRow = document.createElement('tr');
            
            // Sol etiket h√ºcresi - "f(x)"
            const fxLabelCell = document.createElement('td');
            fxLabelCell.textContent = 'f(x)';
            fxLabelCell.style.backgroundColor = '#34495e';
            fxLabelCell.style.color = 'white';
            fxLabelCell.style.fontWeight = 'bold';
            fxLabelCell.style.fontSize = '14px';
            fxLabelCell.style.padding = '8px 6px';
            fxLabelCell.style.textAlign = 'center';
            fxLabelCell.style.minWidth = '50px';
            fxRow.appendChild(fxLabelCell);
            
            // -‚àû b√∂lgesi h√ºcresi
            const minusInfFxCell = document.createElement('td');
            minusInfFxCell.className = 'hatched';
            fxRow.appendChild(minusInfFxCell);
            
            // Sƒ±nƒ±r noktalarƒ± ve i≈üaret aralƒ±klarƒ±
            for (let i = 0; i < boundaries.length; i++) {
                const boundary = boundaries[i];
                const isRoot = roots.includes(boundary);
                
                // Sƒ±nƒ±r noktasƒ±ndaki deƒüer
                const boundaryFxCell = document.createElement('td');
                if (isRoot) {
                    boundaryFxCell.textContent = '0';
                    boundaryFxCell.className = 'root-cell-fx';
                } else {
                    const value = calculateFunctionValue(boundary);
                    // Ondalƒ±klƒ± deƒüeri virg√ºl ile g√∂ster
                    boundaryFxCell.textContent = value.toString().replace('.', ',');
                    boundaryFxCell.className = 'boundary-cell-fx';
                }
                fxRow.appendChild(boundaryFxCell);
                
                // Aralƒ±ktaki i≈üaret (son sƒ±nƒ±r hari√ß)
                if (i < boundaries.length - 1) {
                    const signData = monotonicityData.find(data => 
                        data.startX === boundary && data.endX === boundaries[i + 1]
                    );
                    
                    const signCell = document.createElement('td');
                    if (signData) {
                        signCell.textContent = signData.statusSymbol;
                        signCell.className = signData.status;
                    } else {
                        signCell.textContent = '?';
                        signCell.className = 'pending';
                    }
                    fxRow.appendChild(signCell);
                }
            }
            
            // +‚àû b√∂lgesi h√ºcresi
            const plusInfFxCell = document.createElement('td');
            plusInfFxCell.className = 'hatched';
            fxRow.appendChild(plusInfFxCell);
            
            tableBody.appendChild(xRow);
            tableBody.appendChild(fxRow);
            
            updateSignAnalysisSummary(monotonicityData);
            
            const progressIndicator = document.getElementById('tableProgressIndicator');
            progressIndicator.style.width = '100%';
        }

        // ƒ∞≈üaret analizi √∂zetini g√ºncelle
        function updateSignAnalysisSummary(visibleData) {
            const analysisSummary = document.getElementById('analysisSummary');
            
            // ƒ∞≈üaret analizi √∂zeti kaldƒ±rƒ±ldƒ± - sadece bo≈ü bir div g√∂ster
            analysisSummary.innerHTML = '';
            analysisSummary.style.display = 'none';
            
            // ƒ∞≈üaret b√∂lgeleri analizi
            if ((!isInteractiveMode && visibleData.length === monotonicityData.length) || (isInteractiveMode && isAnswerCorrect)) {
                calculateSignRegions(visibleData);
            }
        }
        
        // ƒ∞≈üaret b√∂lgelerini hesapla
        function calculateSignRegions(data) {
            const intervalAnalysis = document.getElementById('intervalAnalysis');
            const positiveRegions = document.getElementById('positiveRegions');
            const negativeRegions = document.getElementById('negativeRegions');
            const zeroPoints = document.getElementById('zeroPoints');
            
            const positiveIntervals = data.filter(d => d.status === 'positive');
            const negativeIntervals = data.filter(d => d.status === 'negative');
            
            if (positiveIntervals.length > 0) {
                positiveRegions.style.display = 'block';
                const positiveText = positiveIntervals.map(d => d.interval).join(', ');
                positiveRegions.innerHTML = `‚ûï <strong>Pozitif b√∂lgeler:</strong> ${positiveText}`;
            }
            
            if (negativeIntervals.length > 0) {
                negativeRegions.style.display = 'block';
                const negativeText = negativeIntervals.map(d => d.interval).join(', ');
                negativeRegions.innerHTML = `‚ûñ <strong>Negatif b√∂lgeler:</strong> ${negativeText}`;
            }
            
            if (xIntercepts.length > 0) {
                zeroPoints.style.display = 'block';
                zeroPoints.innerHTML = `üéØ <strong>Sƒ±fƒ±r noktalarƒ±:</strong> x = ${xIntercepts.join(', ')}`;
            }
            
            intervalAnalysis.style.display = 'block';
        }

        // ƒ∞nteraktif fonksiyon √ºret
        function generateInteractiveFunction() {
            if (interactiveFunctionCounter >= maxInteractiveFunctions) return;
            
            stopAnimation();
            
            interactiveFunctionCounter++;
            isAnswerCorrect = false;
            nextButtonEnabled = false;
            updateProgressInfo();
            
            xIntercepts = generateXIntercepts();
            currentPoints = generatePointsFromIntercepts(xIntercepts);
            currentGraphType = 'continuous';
            
            prepareSignTableAnalysis();
            currentInteractiveData = [...monotonicityData];
            
            updateGraphTitle();
            createInteractiveTable();
            
            // Yeni egzersizde aralƒ±k analizini gizle
            const intervalAnalysis = document.getElementById('intervalAnalysis');
            intervalAnalysis.style.display = 'none';
            
            startDrawAnimation();
        }
        
        // ƒ∞nteraktif tablo olu≈ütur
        function createInteractiveTable() {
            console.log('Creating interactive table, mode:', isInteractiveMode, 'counter:', interactiveFunctionCounter);
            console.log('Current interactive data:', currentInteractiveData);
            
            const tableBody = document.getElementById('monotonicityTableBody');
            tableBody.innerHTML = '';
            
            if (!currentInteractiveData || currentInteractiveData.length === 0) {
                console.error('No interactive data available');
                tableBody.innerHTML = `
                    <tr>
                        <td colspan="100%" style="text-align: center; padding: 15px; color: #dc3545;">
                            Hata: Analiz verileri bulunamadƒ±!
                        </td>
                    </tr>
                `;
                return;
            }
            
            // Hep aynƒ± i≈üaret tablosu modunu kullan
            createStatusSelectingTable(tableBody);
            
            updateInteractiveAnalysisSummary();
            console.log('Interactive table creation completed');
        }
        
        // ƒ∞≈üaret tablosu olu≈ütur - t√ºm modlar i√ßin
        function createStatusSelectingTable(tableBody) {
            console.log('Creating sign table for', currentInteractiveData.length, 'intervals');
            
            // Sƒ±nƒ±r noktalarƒ±nƒ± ve k√∂kleri birle≈ütir
            const allXValues = currentPoints.map(p => p.x);
            const domainStart = Math.min(...allXValues);
            const domainEnd = Math.max(...allXValues);
            const roots = xIntercepts.sort((a, b) => a - b);
            const boundaries = [domainStart, ...roots, domainEnd].sort((a, b) => a - b);
            
            // X satƒ±rƒ±nƒ± olu≈ütur
            const xRow = document.createElement('tr');
            
            // Sol etiket h√ºcresi - "x"
            const xLabelCell = document.createElement('td');
            xLabelCell.textContent = 'x';
            xLabelCell.style.backgroundColor = '#2c3e50';
            xLabelCell.style.color = 'white';
            xLabelCell.style.fontWeight = 'bold';
            xLabelCell.style.fontSize = '14px';
            xLabelCell.style.padding = '8px 6px';
            xLabelCell.style.textAlign = 'center';
            xLabelCell.style.minWidth = '50px';
            xRow.appendChild(xLabelCell);
            
            // -‚àû h√ºcresi
            const minusInfCell = document.createElement('td');
            minusInfCell.textContent = '-‚àû';
            minusInfCell.className = 'hatched';
            xRow.appendChild(minusInfCell);
            
            // Sƒ±nƒ±r noktalarƒ± ve aralƒ±klar
            for (let i = 0; i < boundaries.length; i++) {
                const boundary = boundaries[i];
                const isRoot = roots.includes(boundary);
                
                // Sƒ±nƒ±r noktasƒ± h√ºcresi
                const boundaryCell = document.createElement('td');
                boundaryCell.textContent = boundary.toString();
                boundaryCell.className = isRoot ? 'root-cell-x' : 'boundary-cell-x';
                xRow.appendChild(boundaryCell);
                
                // Aralƒ±k h√ºcresi (son sƒ±nƒ±r hari√ß)
                if (i < boundaries.length - 1) {
                    const intervalCell = document.createElement('td');
                    intervalCell.textContent = `(${boundary}, ${boundaries[i + 1]})`;
                    intervalCell.style.backgroundColor = '#f8f9fa';
                    intervalCell.style.fontSize = '11px';
                    intervalCell.style.padding = '4px 2px';
                    xRow.appendChild(intervalCell);
                }
            }
            
            // +‚àû h√ºcresi
            const plusInfCell = document.createElement('td');
            plusInfCell.textContent = '+‚àû';
            plusInfCell.className = 'hatched';
            xRow.appendChild(plusInfCell);
            
            // f(x) satƒ±rƒ±nƒ± olu≈ütur - kullanƒ±cƒ± dolduracak
            const fxRow = document.createElement('tr');
            
            // Sol etiket h√ºcresi - "f(x)"
            const fxLabelCell = document.createElement('td');
            fxLabelCell.textContent = 'f(x)';
            fxLabelCell.style.backgroundColor = '#34495e';
            fxLabelCell.style.color = 'white';
            fxLabelCell.style.fontWeight = 'bold';
            fxLabelCell.style.fontSize = '14px';
            fxLabelCell.style.padding = '8px 6px';
            fxLabelCell.style.textAlign = 'center';
            fxLabelCell.style.minWidth = '50px';
            fxRow.appendChild(fxLabelCell);
            
            // -‚àû b√∂lgesi h√ºcresi
            const minusInfFxCell = document.createElement('td');
            minusInfFxCell.className = 'hatched';
            fxRow.appendChild(minusInfFxCell);
            
            // Sƒ±nƒ±r noktalarƒ± ve i≈üaret aralƒ±klarƒ±
            let intervalIndex = 0;
            for (let i = 0; i < boundaries.length; i++) {
                const boundary = boundaries[i];
                const isRoot = roots.includes(boundary);
                
                // Sƒ±nƒ±r noktasƒ±ndaki deƒüer
                const boundaryFxCell = document.createElement('td');
                if (isRoot) {
                    boundaryFxCell.textContent = '0';
                    boundaryFxCell.className = 'root-cell-fx';
                } else {
                    const value = calculateFunctionValue(boundary);
                    // Ondalƒ±klƒ± deƒüeri virg√ºl ile g√∂ster
                    boundaryFxCell.textContent = value.toString().replace('.', ',');
                    boundaryFxCell.className = 'boundary-cell-fx';
                }
                fxRow.appendChild(boundaryFxCell);
                
                // Aralƒ±ktaki i≈üaret (son sƒ±nƒ±r hari√ß) - kullanƒ±cƒ± dolduracak
                if (i < boundaries.length - 1) {
                    const signCell = document.createElement('td');
                    signCell.className = 'status-row interactive-cell';
                    signCell.style.padding = '5px 2px';
                    signCell.style.backgroundColor = '#fff3e0';
                    signCell.innerHTML = `
                        <select id="sign_${intervalIndex}" 
                                style="width: 100%; border: 1px solid #ccc; border-radius: 3px; padding: 4px; font-size: 12px; background: white;"
                                onchange="checkSignAnswer()">
                            <option value="">?</option>
                            <option value="positive">+</option>
                            <option value="negative">‚àí</option>
                        </select>
                    `;
                    fxRow.appendChild(signCell);
                    intervalIndex++;
                }
            }
            
            // +‚àû b√∂lgesi h√ºcresi
            const plusInfFxCell = document.createElement('td');
            plusInfFxCell.className = 'hatched';
            fxRow.appendChild(plusInfFxCell);
            
            tableBody.appendChild(xRow);
            tableBody.appendChild(fxRow);
            
            console.log('Interactive sign table created successfully');
        }
        
        // ƒ∞≈üaret tablosu cevaplarƒ±nƒ± kontrol et
        function checkSignAnswer() {
            let allFilled = true;
            let allCorrect = true;
            
            // Ka√ß adet i≈üaret aralƒ±ƒüƒ± var?
            const intervalCount = currentInteractiveData.length;
            
            for (let i = 0; i < intervalCount; i++) {
                const selectElement = document.getElementById(`sign_${i}`);
                if (!selectElement) continue;
                
                const userAnswer = selectElement.value;
                const correctAnswer = currentInteractiveData[i].status;
                
                if (!userAnswer) {
                    allFilled = false;
                    continue;
                }
                
                const isCorrect = userAnswer === correctAnswer;
                const signCell = selectElement.parentElement;
                
                if (isCorrect) {
                    signCell.style.backgroundColor = '#d4edda';
                    signCell.style.border = '2px solid #28a745';
                } else {
                    signCell.style.backgroundColor = '#f8d7da';
                    signCell.style.border = '2px solid #dc3545';
                    allCorrect = false;
                }
            }
            
            // Geri bildirim ve sonraki buton kontrol√º
            const analysisSummary = document.getElementById('analysisSummary');
            
            if (!allFilled) {
                analysisSummary.innerHTML = `
                    <strong>üìù ƒ∞≈üaret Tablosu...</strong> 
                    T√ºm aralƒ±klarƒ±n i≈üaretini se√ßin.
                `;
                analysisSummary.style.backgroundColor = 'rgba(255, 152, 0, 0.1)';
                analysisSummary.style.border = '1px solid #ffcc02';
                nextButtonEnabled = false;
                isAnswerCorrect = false;
            } else if (allCorrect) {
                analysisSummary.innerHTML = `
                    <strong>‚úÖ M√ºkemmel!</strong> 
                    ƒ∞≈üaret tablosunu doƒüru tamamladƒ±nƒ±z! 
                    <span style="color: #28a745;">Sonraki soruya ge√ßebilirsiniz.</span>
                `;
                analysisSummary.style.backgroundColor = 'rgba(40, 167, 69, 0.1)';
                analysisSummary.style.border = '1px solid #28a745';
                nextButtonEnabled = true;
                isAnswerCorrect = true;
                
                // Aralƒ±k analizi g√∂ster
                calculateSignRegions(currentInteractiveData);
            } else {
                analysisSummary.innerHTML = `
                    <strong>‚ùå Kontrol edin!</strong> 
                    Bazƒ± i≈üaretler yanlƒ±≈ü. Kƒ±rmƒ±zƒ± i≈üaretlenen aralƒ±klarƒ± d√ºzeltin.
                `;
                analysisSummary.style.backgroundColor = 'rgba(220, 53, 69, 0.1)';
                analysisSummary.style.border = '1px solid #dc3545';
                nextButtonEnabled = false;
                isAnswerCorrect = false;
            }
            
            updateProgressInfo();
        }
        
        // Cevaplarƒ± kontrol et (eski fonksiyon - kullanƒ±lmƒ±yor artƒ±k)
        function checkAnswer() {
            const isIntervalMode = interactiveFunctionCounter > 5;
            let allFilled = true;
            let allCorrect = true;
            
            currentInteractiveData.forEach((data, index) => {
                let userIntervalAnswer = '';
                let userStatusAnswer = '';
                
                if (isIntervalMode) {
                    // Aralƒ±k yazma modu
                    userIntervalAnswer = document.getElementById(`interval_${index}`).value.trim();
                    userStatusAnswer = document.getElementById(`status_${index}`).value;
                    
                    if (!userIntervalAnswer || !userStatusAnswer) {
                        allFilled = false;
                        return;
                    }
                    
                    // Aralƒ±k kontrol√º
                    const cleanUserInterval = userIntervalAnswer.replace(/\s/g, '');
                    const cleanCorrectInterval = data.interval.replace(/\s/g, '');
                    const intervalCorrect = cleanUserInterval === cleanCorrectInterval;
                    
                    // Durum kontrol√º
                    const statusCorrect = userStatusAnswer === data.status;
                    
                    // G√∂rsel geri bildirim
                    const intervalCell = document.getElementById(`interval_${index}`).parentElement;
                    const statusCell = document.getElementById(`status_${index}`).parentElement;
                    
                    if (intervalCorrect) {
                        intervalCell.style.backgroundColor = '#d4edda';
                        intervalCell.style.border = '2px solid #28a745';
                    } else {
                        intervalCell.style.backgroundColor = '#f8d7da';
                        intervalCell.style.border = '2px solid #dc3545';
                        allCorrect = false;
                    }
                    
                    if (statusCorrect) {
                        statusCell.style.backgroundColor = '#d4edda';
                        statusCell.style.border = '2px solid #28a745';
                    } else {
                        statusCell.style.backgroundColor = '#f8d7da';
                        statusCell.style.border = '2px solid #dc3545';
                        allCorrect = false;
                    }
                    
                } else {
                    // Durum se√ßme modu
                    userStatusAnswer = document.getElementById(`status_${index}`).value;
                    
                    if (!userStatusAnswer) {
                        allFilled = false;
                        return;
                    }
                    
                    const statusCorrect = userStatusAnswer === data.status;
                    const statusCell = document.getElementById(`status_${index}`).parentElement;
                    
                    if (statusCorrect) {
                        statusCell.style.backgroundColor = '#d4edda';
                        statusCell.style.border = '2px solid #28a745';
                    } else {
                        statusCell.style.backgroundColor = '#f8d7da';
                        statusCell.style.border = '2px solid #dc3545';
                        allCorrect = false;
                    }
                }
            });
            
            // Geri bildirim ve sonraki buton kontrol√º
            const analysisSummary = document.getElementById('analysisSummary');
            
            if (!allFilled) {
                analysisSummary.innerHTML = `
                    <strong>üìù Devam edin...</strong> 
                    T√ºm alanlarƒ± doldurun.
                `;
                analysisSummary.style.backgroundColor = 'rgba(255, 152, 0, 0.1)';
                analysisSummary.style.border = '1px solid #ffcc02';
                isAnswerCorrect = false;
                nextButtonEnabled = false;
            } else if (allCorrect) {
                analysisSummary.innerHTML = `
                    <strong>üéâ M√ºkemmel!</strong> 
                    T√ºm cevaplar doƒüru! Sonraki fonksiyona ge√ßebilirsiniz.
                `;
                analysisSummary.style.backgroundColor = '#d4edda';
                analysisSummary.style.border = '1px solid #28a745';
                isAnswerCorrect = true;
                nextButtonEnabled = true;
                
                // Doƒüru cevap verildikten sonra i≈üaret analizi g√∂ster
                calculateSignRegions(currentInteractiveData);
            } else {
                analysisSummary.innerHTML = `
                    <strong>‚ö†Ô∏è Tekrar deneyin!</strong> 
                    Kƒ±rmƒ±zƒ± i≈üaretli alanlarƒ± kontrol edin.
                `;
                analysisSummary.style.backgroundColor = '#f8d7da';
                analysisSummary.style.border = '1px solid #dc3545';
                isAnswerCorrect = false;
                nextButtonEnabled = false;
            }
            
            updateProgressInfo();
        }
        
        // ƒ∞nteraktif analiz √∂zetini g√ºncelle
        function updateInteractiveAnalysisSummary() {
            const analysisSummary = document.getElementById('analysisSummary');
            
            analysisSummary.innerHTML = `
                <strong>üéØ ƒ∞≈üaret Tablosu Egzersizi #${interactiveFunctionCounter}</strong><br>
                üìã <strong>G√∂rev:</strong> Fonksiyonun her aralƒ±ktaki i≈üaretini belirleyin<br>
                ‚ûï Pozitif aralƒ±klar i√ßin "<strong>+</strong>" se√ßin<br>
                ‚ûñ Negatif aralƒ±klar i√ßin "<strong>‚àí</strong>" se√ßin<br>
                üí° <strong>ƒ∞pucu:</strong> K√∂klerin arasƒ±ndaki aralƒ±klarda fonksiyonun i≈üareti deƒüi≈üir
            `;
            
            analysisSummary.style.backgroundColor = 'rgba(33, 150, 243, 0.1)';
            analysisSummary.style.border = '1px solid #2196F3';
            
            // ƒ∞nteraktif modda ba≈ülangƒ±√ßta aralƒ±k analizini gizle
            const intervalAnalysis = document.getElementById('intervalAnalysis');
            intervalAnalysis.style.display = 'none';
        }

        // ƒ∞≈üaret analizi √∂zetini g√ºncelle
        function updateAnalysisSummary(visibleData) {
            const analysisSummary = document.getElementById('analysisSummary');
            
            // ƒ∞≈üaret analizi √∂zeti kaldƒ±rƒ±ldƒ± - sadece bo≈ü bir div g√∂ster
            analysisSummary.innerHTML = '';
            analysisSummary.style.display = 'none';
            
            // ƒ∞≈üaret b√∂lgeleri analizi
            if ((!isInteractiveMode && totalVisible === visibleData.length) || (isInteractiveMode && isAnswerCorrect)) {
                calculateSignRegions(visibleData);
            }
            
            // ƒ∞≈üaret b√∂lgeleri analizi
            if ((!isInteractiveMode && totalVisible === visibleData.length) || (isInteractiveMode && isAnswerCorrect)) {
                calculateSignRegions(visibleData);
            }
        }
        
        // ƒ∞≈üaret b√∂lgelerini hesapla
        function calculateSignRegions(data) {
            const intervalAnalysis = document.getElementById('intervalAnalysis');
            const positiveRegions = document.getElementById('positiveRegions');
            const negativeRegions = document.getElementById('negativeRegions');
            const zeroPoints = document.getElementById('zeroPoints');
            
            const positiveIntervals = data.filter(d => d.status === 'positive');
            const negativeIntervals = data.filter(d => d.status === 'negative');
            
            if (positiveIntervals.length > 0) {
                positiveRegions.style.display = 'block';
                const positiveText = positiveIntervals.map(d => d.interval).join(', ');
                positiveRegions.innerHTML = `‚ûï <strong>Pozitif b√∂lgeler:</strong> ${positiveText}`;
            }
            
            if (negativeIntervals.length > 0) {
                negativeRegions.style.display = 'block';
                const negativeText = negativeIntervals.map(d => d.interval).join(', ');
                negativeRegions.innerHTML = `‚ûñ <strong>Negatif b√∂lgeler:</strong> ${negativeText}`;
            }
            
            if (xIntercepts.length > 0) {
                zeroPoints.style.display = 'block';
                zeroPoints.innerHTML = `üéØ <strong>Sƒ±fƒ±r noktalarƒ±:</strong> x = ${xIntercepts.join(', ')}`;
            }
            
            intervalAnalysis.style.display = 'block';
        }

        // Yatay doƒüru testini ba≈ülat
        function startHorizontalLineTest() {
            if (currentPoints.length === 0) return;
            
            isHorizontalLineTestActive = true;
            testProgress = 0;
            intersectionPoints = [];
            
            document.getElementById('startTestBtn').style.display = 'none';
            document.getElementById('testProgress').style.display = 'block';
            
            // Test aralƒ±ƒüƒ±nƒ± belirle (Y deƒüerlerinin aralƒ±ƒüƒ±)
            const yValues = currentPoints.map(p => p.y);
            const minY = Math.min(...yValues);
            const maxY = Math.max(...yValues);
            
            // Test i√ßin Y aralƒ±ƒüƒ±nƒ± geni≈ület
            const testMinY = minY - 2;
            const testMaxY = maxY + 2;
            
            animateHorizontalLineTest(testMinY, testMaxY);
        }

        // Yatay doƒüru testini durdur
        function stopHorizontalLineTest() {
            if (testAnimationId) {
                cancelAnimationFrame(testAnimationId);
                testAnimationId = null;
            }
            isHorizontalLineTestActive = false;
        }

        // Yatay doƒüru testi animasyonu
        function animateHorizontalLineTest(minY, maxY) {
            const testSpeed = 0.005; // √áok daha yava≈ü animasyon (0.02'den 0.005'e d√º≈ü√ºr√ºld√º)
            
            function animate() {
                if (!isHorizontalLineTestActive) return;
                
                testProgress += testSpeed;
                
                if (testProgress >= 1) {
                    testProgress = 1;
                    isHorizontalLineTestActive = false;
                    analyzeTestResults();
                    return;
                }
                
                // Mevcut Y deƒüerini hesapla
                horizontalLineY = minY + (maxY - minY) * testProgress;
                
                // Kesi≈üim noktalarƒ±nƒ± bul
                findIntersections(horizontalLineY);
                
                // Progress g√ºncelle
                document.getElementById('progressFill').style.width = (testProgress * 100) + '%';
                document.getElementById('testInfo').textContent = 
                    `Y = ${horizontalLineY.toFixed(1)} seviyesinde test ediliyor... Kesi≈üim: ${intersectionPoints.length} nokta`;
                
                // Grafik √ßiz
                drawGraph();
                drawHorizontalLine(horizontalLineY);
                drawIntersectionPoints();
                
                testAnimationId = requestAnimationFrame(animate);
            }
            
            animate();
        }

        // Kesi≈üim noktalarƒ±nƒ± bul
        function findIntersections(y) {
            intersectionPoints = [];
            
            for (let i = 0; i < currentPoints.length - 1; i++) {
                const p1 = currentPoints[i];
                const p2 = currentPoints[i + 1];
                
                // Y deƒüeri bu segment aralƒ±ƒüƒ±nda mƒ± kontrol et
                const minY = Math.min(p1.y, p2.y);
                const maxY = Math.max(p1.y, p2.y);
                
                // Yatay doƒüru bu segment ile kesi≈üiyor mu?
                if (minY <= y && y <= maxY) {
                    if (Math.abs(p1.y - p2.y) < 0.001) {
                        // Yatay segment - eƒüer y deƒüeri bu segmentin y deƒüerine e≈üitse
                        if (Math.abs(p1.y - y) < 0.001) {
                            // Sadece segment ba≈ülangƒ±cƒ±nƒ± ekle (√ßift sayƒ±mƒ± √∂nle)
                            if (intersectionPoints.length === 0 || 
                                Math.abs(intersectionPoints[intersectionPoints.length - 1].x - p1.x) > 0.1) {
                                intersectionPoints.push({x: p1.x, y: y});
                            }
                        }
                    } else {
                        // Normal kesi≈üim - doƒürusal interpolasyon
                        const t = (y - p1.y) / (p2.y - p1.y);
                        const x = p1.x + t * (p2.x - p1.x);
                        
                        // √áift kesi≈üimi √∂nlemek i√ßin yakƒ±n noktalarƒ± kontrol et
                        let isDuplicate = false;
                        for (let j = 0; j < intersectionPoints.length; j++) {
                            if (Math.abs(intersectionPoints[j].x - x) < 0.1) {
                                isDuplicate = true;
                                break;
                            }
                        }
                        
                        if (!isDuplicate) {
                            intersectionPoints.push({x: x, y: y});
                        }
                    }
                }
            }
            
            // Kesi≈üim noktalarƒ±nƒ± X koordinatƒ±na g√∂re sƒ±rala
            intersectionPoints.sort((a, b) => a.x - b.x);
        }

        // Yatay doƒüru √ßiz
        function drawHorizontalLine(y) {
            const width = canvas.style.width ? parseInt(canvas.style.width) : canvas.width;
            const padding = Math.min(width, canvas.height) * 0.1;
            
            const canvasY = toCanvasY(y);
            const startX = padding;
            const endX = width - padding;
            
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.globalAlpha = 0.8;
            
            ctx.beginPath();
            ctx.moveTo(startX, canvasY);
            ctx.lineTo(endX, canvasY);
            ctx.stroke();
            
            ctx.setLineDash([]);
            ctx.globalAlpha = 1;
        }

        // Kesi≈üim noktalarƒ±nƒ± √ßiz
        function drawIntersectionPoints() {
            intersectionPoints.forEach(point => {
                const cx = toCanvasX(point.x);
                const cy = toCanvasY(point.y);
                
                ctx.fillStyle = '#ff6b6b';
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                
                ctx.beginPath();
                ctx.arc(cx, cy, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            });
        }

        // Test sonu√ßlarƒ±nƒ± analiz et
        function analyzeTestResults() {
            const yValues = currentPoints.map(p => p.y);
            const minY = Math.min(...yValues);
            const maxY = Math.max(...yValues);
            
            let maxIntersections = 0;
            let examples = [];
            
            // Daha sƒ±k test yapmak i√ßin adƒ±m boyutunu k√º√ß√ºlt
            const step = (maxY - minY) / 20; // 20 adƒ±mda test yap
            
            for (let y = minY - 1; y <= maxY + 1; y += Math.max(0.2, step)) {
                findIntersections(y);
                const count = intersectionPoints.length;
                
                if (count > maxIntersections) {
                    maxIntersections = count;
                }
                
                // √ñrnek topla
                if (examples.length < 5 && count > 0) {
                    examples.push({
                        y: y,
                        intersections: count,
                        points: [...intersectionPoints]
                    });
                }
            }
            
            // √ñzel durum: fonksiyonun kritik noktalarƒ±nda da test yap
            const criticalYValues = [...new Set(yValues)]; // Benzersiz Y deƒüerleri
            criticalYValues.forEach(y => {
                findIntersections(y);
                const count = intersectionPoints.length;
                if (count > maxIntersections) {
                    maxIntersections = count;
                }
            });
            
            // Bire bir kontrol√º (her yatay doƒüru en fazla 1 kez keser)
            const isOneToOne = maxIntersections <= 1;
            
            console.log('Maksimum kesi≈üim sayƒ±sƒ±:', maxIntersections);
            console.log('Bire bir mi?', isOneToOne);
            
            displayResults(isOneToOne, examples, maxIntersections);
        }

        // Sonu√ßlarƒ± g√∂r√ºnt√ºle
        function displayResults(isOneToOne, examples, maxIntersections) {
            document.getElementById('testProgress').style.display = 'none';
            
            const functionProperties = document.getElementById('functionProperties');
            
            let oneToOneText, summaryText;
            
            if (isOneToOne) {
                oneToOneText = `
                    <div class="analysis-result result-success">
                        ‚úÖ Bƒ∞RE Bƒ∞R FONKSƒ∞YON
                        <div style="font-size: 12px; margin-top: 5px;">
                            Her yatay doƒüru fonksiyonu en fazla bir noktada keser.
                        </div>
                    </div>
                `;
                summaryText = "Bu fonksiyon Bƒ∞RE Bƒ∞R'dir.";
            } else {
                oneToOneText = `
                    <div class="analysis-result result-warning">
                        ‚ùå Bƒ∞RE Bƒ∞R DEƒûƒ∞L
                        <div style="font-size: 12px; margin-top: 5px;">
                            Bazƒ± yatay doƒürular fonksiyonu ${maxIntersections} noktada kesiyor.
                        </div>
                    </div>
                `;
                summaryText = "Bu fonksiyon bire bir deƒüildir.";
            }
            
            const ontoText = `
                <div class="analysis-result result-info">
                    üìä G√ñR√úNT√ú K√úMESƒ∞ ANALƒ∞Zƒ∞
                    <div style="font-size: 12px; margin-top: 5px;">
                        Fonksiyonun y deƒüerleri: ${Math.min(...currentPoints.map(p => p.y)).toFixed(1)} ile ${Math.max(...currentPoints.map(p => p.y)).toFixed(1)} arasƒ±nda
                    </div>
                </div>
            `;
            
            let exampleText = "";
            if (examples.length > 0) {
                exampleText = `
                    <div class="property-box">
                        <h5>üìù Test √ñrnekleri</h5>
                        ${examples.slice(0, 3).map(ex => 
                            `<div style="margin: 5px 0; font-size: 13px;">
                                Y = ${ex.y.toFixed(1)} ‚Üí ${ex.intersections} kesi≈üim noktasƒ±
                            </div>`
                        ).join('')}
                    </div>
                `;
            }
            
            functionProperties.innerHTML = `
                <div class="property-box">
                    <h5>üéØ Test Sonu√ßlarƒ±</h5>
                    ${oneToOneText}
                    ${ontoText}
                    <div style="margin-top: 15px; padding: 10px; background: #e3f2fd; border-radius: 6px; font-weight: 500;">
                        ${summaryText}
                    </div>
                </div>
                ${exampleText}
            `;
            
            // Sonraki butonunu aktif et
            if (!isInteractiveMode) {
                document.getElementById('nextBtn').style.display = 'flex';
                nextButtonEnabled = true;
            }
        }

        // Test butonunu g√∂ster
        function showTestButton() {
            if (!isInteractiveMode) {
                document.getElementById('startTestBtn').style.display = 'flex';
            }
        }

        // Analizi sƒ±fƒ±rla
        function resetAnalysis() {
            const functionProperties = document.getElementById('functionProperties');
            functionProperties.innerHTML = `
                <div class="property-box">
                    <h5>üîç Fonksiyon Analizi</h5>
                    <p>Grafik √ßizildikten sonra yatay doƒüru testi ile fonksiyonun √∂zelliklerini analiz edeceƒüiz.</p>
                </div>
            `;
            
            document.getElementById('testProgress').style.display = 'none';
            document.getElementById('startTestBtn').style.display = 'none';
            document.getElementById('nextBtn').style.display = 'none';
            
            // Test deƒüi≈ükenlerini sƒ±fƒ±rla
            isHorizontalLineTestActive = false;
            testProgress = 0;
            intersectionPoints = [];
            testResults = {
                isOneToOne: false,
                isOnto: false,
                examples: []
            };
        }

        // ƒ∞nteraktif fonksiyon √ºret (placeholder)
        function generateInteractiveFunction() {
            // ƒ∞nteraktif mod i√ßin placeholder
            console.log('Interactive mode not implemented yet');
        }

    </script>
</body>
</html>
