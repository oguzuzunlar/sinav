<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Fonksiyonlarda Artan ve Azalanlƒ±k Etkinliƒüi</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
            color: #333;
            line-height: 1.4;
            min-height: 100vh;
            padding: 10px;
            overflow-x: hidden;
        }

        .container {
            width: 100%;
            max-width: 800px;
            background-color: rgba(255, 255, 255, 0.98);
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            margin: 0 auto;
        }

        /* Desktop layout - iki s√ºtunlu */
        @media (min-width: 769px) {
            .container {
                max-width: 100%;
                width: 100%;
            }
            
            .content {
                display: flex;
                gap: 20px;
                align-items: flex-start;
            }
            
            .graph-container {
                flex: 1;
                min-width: 0;
            }
            
            .monotonicity-table {
                flex: 1;
                min-width: 0;
            }
        }

        header {
            background: linear-gradient(to right, #1a2a6c, #b21f1f);
            color: white;
            padding: 15px;
            text-align: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .logo {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 5px;
        }

        h1 {
            font-size: 1.2rem;
            margin: 0;
            line-height: 1.3;
        }

        .progress-info {
            font-size: 0.9rem;
            opacity: 0.9;
            margin-top: 5px;
        }

        .content {
            padding: 15px;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 12px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }

        .btn {
            padding: 8px 12px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            touch-action: manipulation;
        }

        .btn:active {
            transform: scale(0.98);
        }

        .btn-primary {
            background: linear-gradient(135deg, #1a2a6c, #2d4aa7);
            color: white;
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(135deg, #ffc107, #ffb300);
            color: #333;
        }

        .btn-success:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .graph-container {
            background-color: #f8f9fa;
            padding: 5px;
            border-radius: 4px;
            text-align: center;
            margin-bottom: 5px;
            border: 1px solid #dee2e6;
        }

        .graph-header {
            margin-bottom: 15px;
        }

        .graph-header h3 {
            color: #1a2a6c;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            text-align: center;
            line-height: 1.3;
        }

        .canvas-wrapper {
            position: relative;
            width: 100%;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            margin: 0 auto;
            aspect-ratio: 1;
            border: 2px solid #dee2e6;
            overflow: hidden;
        }

        /* Desktop'ta grafik alanƒ±nƒ± optimize et */
        @media (min-width: 769px) {
            .canvas-wrapper {
                aspect-ratio: 1.2;
                max-height: 70vh;
            }
        }

        #functionChart {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }

        .monotonicity-table {
            background-color: #fff8e1;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #ff9800;
            position: relative;
            overflow: hidden;
        }

        .monotonicity-table h4 {
            color: #e65100;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1rem;
        }

        .table-container {
            position: relative;
            background: #fff;
            border-radius: 8px;
            border: 2px solid #ffcc02;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            overflow-x: auto;
        }

        .monotonicity-table table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
            min-width: 300px;
        }

        .monotonicity-table th,
        .monotonicity-table td {
            padding: 8px 4px;
            text-align: center;
            border: 1px solid #e0e0e0;
            position: relative;
            transition: all 0.3s ease;
            min-width: 60px;
        }

        .monotonicity-table .interval-row {
            background: linear-gradient(135deg, #ff9800, #ffb74d);
            color: white;
            font-weight: bold;
            font-size: 11px;
        }

        .monotonicity-table .status-row {
            background: #fafafa;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-size: 10px;
        }

        .monotonicity-table .increasing {
            background: linear-gradient(135deg, #e8f5e8, #c8e6c9);
            color: #2e7d32;
        }

        .monotonicity-table .decreasing {
            background: linear-gradient(135deg, #ffebee, #ffcdd2);
            color: #c62828;
        }

        .monotonicity-table .constant {
            background: linear-gradient(135deg, #e3f2fd, #bbdefb);
            color: #1565c0;
        }

        .interactive-cell {
            background: #f8f9fa !important;
            padding: 5px 2px !important;
        }

        .interactive-cell input,
        .interactive-cell select {
            width: 100%;
            border: 1px solid #ccc;
            border-radius: 3px;
            padding: 2px;
            font-size: 10px;
            text-align: center;
        }

        .animated-row {
            animation: slideInLeft 0.5s ease-out;
            border-left: 4px solid #ff9800;
        }

        @keyframes slideInLeft {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .progress-indicator {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: linear-gradient(90deg, rgba(255, 152, 0, 0.1), rgba(255, 152, 0, 0.3));
            transition: width 0.3s ease;
            pointer-events: none;
        }

        .analysis-summary {
            margin-top: 15px;
            padding: 12px;
            background: rgba(255, 152, 0, 0.1);
            border-radius: 6px;
            border: 1px solid #ffcc02;
            font-size: 12px;
            line-height: 1.4;
            display: none;
        }

        .trend-icon {
            display: inline-block;
            margin-right: 5px;
            font-size: 14px;
        }

        .trend-up::before {
            content: "‚ÜóÔ∏è";
        }

        .trend-down::before {
            content: "‚ÜòÔ∏è";
        }

        .trend-flat::before {
            content: "‚û°Ô∏è";
        }

        /* Mobil optimizasyonlarƒ± */
        @media (max-width: 768px) {
            body {
                padding: 5px;
            }
            
            .container {
                border-radius: 5px;
                max-width: 800px;
            }
            
            .content {
                display: block;
            }
            
            header {
                padding: 10px;
            }
            
            h1 {
                font-size: 1rem;
            }
            
            .content {
                padding: 10px;
            }
            
            .graph-container {
                padding: 10px;
                margin-bottom: 15px;
            }
            
            .monotonicity-table {
                padding: 10px;
            }
            
            .monotonicity-table table {
                font-size: 10px;
            }
            
            .monotonicity-table th,
            .monotonicity-table td {
                padding: 6px 2px;
                min-width: 50px;
            }
        }

        /* Landscape orientation */
        @media (orientation: landscape) and (max-height: 600px) {
            .canvas-wrapper {
                aspect-ratio: 4/3;
            }
        }

        /* Welcome Section Styles */
        .welcome-container {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
        }

        .welcome-content {
            max-width: 900px;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.3);
            text-align: center;
            animation: welcomeFadeIn 1s ease-out;
        }

        @keyframes welcomeFadeIn {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .welcome-header {
            margin-bottom: 30px;
        }

        .welcome-logo {
            margin-bottom: 15px;
        }

        .welcome-title {
            font-size: 2.5rem;
            color: #1a2a6c;
            margin-bottom: 8px;
            font-weight: 700;
        }

        .welcome-subtitle {
            font-size: 1.2rem;
            color: #b21f1f;
            font-weight: 500;
            margin-bottom: 20px;
        }

        .welcome-description {
            text-align: left;
            margin-bottom: 30px;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .feature-item {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .feature-item:hover {
            border-color: #1a2a6c;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(26, 42, 108, 0.1);
        }

        .feature-icon {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .feature-item h3 {
            color: #1a2a6c;
            margin-bottom: 8px;
            font-size: 1.1rem;
        }

        .feature-item p {
            color: #6c757d;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .learning-objectives,
        .how-it-works {
            background: #fff;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .learning-objectives h3,
        .how-it-works h3 {
            color: #1a2a6c;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .learning-objectives ul {
            list-style: none;
            padding-left: 0;
        }

        .learning-objectives li {
            padding: 8px 0;
            border-bottom: 1px solid #f1f3f4;
            position: relative;
            padding-left: 25px;
        }

        .learning-objectives li:before {
            content: "‚úì";
            position: absolute;
            left: 0;
            color: #28a745;
            font-weight: bold;
        }

        .learning-objectives li:last-child {
            border-bottom: none;
        }

        .steps {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .step {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px;
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border-radius: 10px;
        }

        .step-number {
            background: linear-gradient(135deg, #1a2a6c, #2c5aa0);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.1rem;
            flex-shrink: 0;
        }

        .step-content {
            flex: 1;
        }

        .step-content strong {
            color: #1a2a6c;
        }

        .welcome-actions {
            text-align: center;
        }

        .start-btn {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .start-btn:hover {
            background: linear-gradient(135deg, #218838, #1cc88a);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(40, 167, 69, 0.3);
        }

        .welcome-note {
            color: #6c757d;
            font-size: 0.9rem;
            max-width: 400px;
            margin: 0 auto;
            line-height: 1.4;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .welcome-content {
                padding: 20px;
                margin: 10px;
            }

            .welcome-title {
                font-size: 1.8rem;
            }

            .welcome-subtitle {
                font-size: 1rem;
            }

            .feature-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }

            .steps {
                gap: 10px;
            }

            .step {
                padding: 12px;
            }

            .step-number {
                width: 35px;
                height: 35px;
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <!-- Giri≈ü B√∂l√ºm√º -->
    <div id="welcomeSection" class="welcome-container">
        <div class="welcome-content">
            <div class="welcome-header">
                <div class="welcome-logo">
                    <svg xmlns="http://www.w3.org/2000/svg" width="60" height="60" viewBox="0 0 24 24" fill="none" stroke="#FFD700" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M3 3v18h18"></path>
                        <path d="M19 9l-5 5-4-4-3 3"></path>
                    </svg>
                </div>
                <h1 class="welcome-title">Fonksiyonlarda Artan ve Azalanlƒ±k</h1>
                <p class="welcome-subtitle">ƒ∞nteraktif Matematik Etkinliƒüi</p>
            </div>
            
            <div class="welcome-description">
                <div class="feature-grid">
                    <div class="feature-item">
                        <div class="feature-icon">üìä</div>
                        <h3>Simulasyon Modu</h3>
                        <p>5 farklƒ± fonksiyonun monotonluk analizini animasyonlu olarak inceleyin</p>
                    </div>
                    <div class="feature-item">
                        <div class="feature-icon">üéØ</div>
                        <h3>Sƒ±ra Sende Modu</h3>
                        <p>10 egzersizde fonksiyonlarƒ±n artan/azalan aralƒ±klarƒ±nƒ± kendiniz bulun</p>
                    </div>
                    <div class="feature-item">
                        <div class="feature-icon">üìê</div>
                        <h3>ƒ∞ki Farklƒ± Zorluk</h3>
                        <p>Durum se√ßme ve aralƒ±k yazma modlarƒ±nda yeteneklerinizi test edin</p>
                    </div>
                </div>
                
                <div class="learning-objectives">
                    <h3>üéì √ñƒürenme Hedefleri:</h3>
                    <ul>
                        <li>Fonksiyonlarƒ±n grafik √ºzerindeki artan ve azalan davranƒ±≈ülarƒ±nƒ± anlama</li>
                        <li>Monotonluk aralƒ±klarƒ±nƒ± doƒüru ≈üekilde belirleme</li>
                        <li>Grafik okuma ve analiz becerilerini geli≈ütirme</li>
                        <li>Matematiksel notation kullanƒ±mƒ±nƒ± peki≈ütirme</li>
                    </ul>
                </div>
                
                <div class="how-it-works">
                    <h3>üöÄ Nasƒ±l √áalƒ±≈üƒ±r:</h3>
                    <div class="steps">
                        <div class="step">
                            <span class="step-number">1</span>
                            <div class="step-content">
                                <strong>Simulasyon:</strong> √ñnce 5 fonksiyonun analizini izleyin ve √∂ƒürenin
                            </div>
                        </div>
                        <div class="step">
                            <span class="step-number">2</span>
                            <div class="step-content">
                                <strong>Uygulama:</strong> "Sƒ±ra Sende" butonuna tƒ±klayarak egzersizlere ba≈ülayƒ±n
                            </div>
                        </div>
                        <div class="step">
                            <span class="step-number">3</span>
                            <div class="step-content">
                                <strong>Deƒüerlendirme:</strong> Her egzersizde cevaplarƒ±nƒ±zƒ± kontrol edin ve √∂ƒürenin
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="welcome-actions">
                <button id="startSimulationBtn" class="start-btn primary">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polygon points="5,3 19,12 5,21"></polygon>
                    </svg>
                    Simulasyonu Ba≈ülat
                </button>
                <p class="welcome-note">
                    üí° <strong>ƒ∞pucu:</strong> ƒ∞lk kez kullanƒ±yorsanƒ±z simulasyon modunda ba≈ülamanƒ±zƒ± √∂neririz!
                </p>
            </div>
        </div>
    </div>

    <div class="container" id="mainApplication" style="display: none;">
        <header>
            <div class="logo">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#FFD700" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 12h18m-9-9v18"></path>
                    <circle cx="12" cy="12" r="3"></circle>
                </svg>
                <h1>Fonksiyonlarda Artan ve Azalanlƒ±k Etkinliƒüi</h1>
            </div>
            <div style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap;">
                <div class="progress-info" id="progressInfo">
                    Fonksiyon: 0/10
                </div>
            </div>
        </header>
        
        <div class="content">
            
            <div class="graph-container">
                <div class="graph-header" style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 5px;">

                    <div class="controls" style="margin: 0; flex-shrink: 0;">
                        <button class="btn btn-primary" id="generateBtn">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M9 18l6-6-6-6"></path>
                            </svg>
                            Sonraki Fonksiyon
                        </button>

                        <button class="btn btn-success" id="nextBtn" style="display: none;" disabled>
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M9 18l6-6-6-6"></path>
                            </svg>
                            Sonraki Fonksiyon
                        </button>
                    </div>
                </div>
                <div class="canvas-wrapper">
                    <canvas id="functionChart"></canvas>
                </div>
            </div>

            <div class="monotonicity-table">
                <h4>
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#e65100" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M3 12h18"></path>
                        <path d="M8 8l4-4 4 4"></path>
                        <path d="M8 16l4 4 4-4"></path>
                    </svg>
                    Dinamik Artan/Azalan ƒ∞ncelemesi
                </h4>
                <div class="table-container">
                    <div class="progress-indicator" id="tableProgressIndicator"></div>
                    <table id="monotonicityTable">
                        <tbody id="monotonicityTableBody">
                            <tr>
                                <td colspan="100%" style="text-align: center; padding: 20px; color: #666;">
                                    Grafik √ºretildikten sonra inceleme tablosu burada g√∂r√ºnt√ºlenecektir.
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <div class="interval-analysis" id="intervalAnalysis" style="display: none; margin-top: 10px; padding: 12px; background: #f8f9fa; border-radius: 6px; border-left: 4px solid #007bff;">
                  
                    <div style="margin-top: 6px; font-size: 13px;">
                        <div id="longestIncreasing" style="display: none;">‚ÜóÔ∏è <strong>En geni≈ü artan aralƒ±k:</strong> -</div>
                        <div id="longestDecreasing" style="display: none;">‚ÜòÔ∏è <strong>En geni≈ü azalan aralƒ±k:</strong> -</div>
                        <div id="longestConstant" style="display: none;">‚û°Ô∏è <strong>En geni≈ü sabit aralƒ±k:</strong> -</div>
                    </div>
                </div>
                <div class="analysis-summary" id="analysisSummary">
                    <strong>üìä ƒ∞nceleme √ñzeti:</strong> Hen√ºz inceleme ba≈ülamadƒ±. Grafik animasyonu ba≈üladƒ±ƒüƒ±nda dinamik olarak g√ºncellenecektir.
                </div>
                
                <!-- G√∂reviniz b√∂l√ºm√º - sadece SÔøΩra sende modunda g√∂r√ºn√ºr -->
                <div class="task-instructions" id="taskInstructions" style="display: none; margin-top: 15px; padding: 15px; background: linear-gradient(135deg, #f8f9fa, #e9ecef); border-radius: 8px; border-left: 4px solid #007bff;">
                    <div style="display: flex; align-items: center; margin-bottom: 10px;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#007bff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                            <circle cx="12" cy="12" r="10"></circle>
                            <path d="M9,12l2,2 4,-4"></path>
                        </svg>
                        <strong style="color: #007bff; font-size: 16px;">üìã G√∂reviniz</strong>
                    </div>
                    <div id="taskContent" style="font-size: 14px; line-height: 1.5; color: #495057;">
                        <!-- G√∂rev i√ßeriƒüi buraya gelecek -->
                    </div>
                </div>
                
                <!-- Sƒ±ra sende mod kontrol butonlarƒ± -->
                <div class="interactive-controls" id="interactiveControls" style="display: none; margin-top: 15px; text-align: center;">
                    <button class="btn btn-warning" id="checkBtn" style="margin-right: 10px;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M9 12l2 2 4-4"></path>
                            <circle cx="12" cy="12" r="10"></circle>
                        </svg>
                        Kontrol Et
                    </button>
                    <div class="feedback-message" id="feedbackMessage" style="margin-top: 10px; padding: 10px; border-radius: 6px; display: none;"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global deƒüi≈ükenler
        let currentPoints = [];
        let currentGraphType = '';
        let xIntercepts = [];
        let canvas, ctx;
        let animationId = null;
        let animationProgress = 0;
        let isAnimating = false;
        let animationSpeed = 0.01; // Daima yava≈ü animasyon
        let monotonicityData = [];
        let criticalPoints = [];
        let currentAnalysisIndex = 0;
        let functionCounter = 0;
        let maxFunctions = 5;
        let isInteractiveMode = false;
        let interactiveFunctionCounter = 0;
        let maxInteractiveFunctions = 10;
        let currentInteractiveData = null;
        let isAnswerCorrect = false;
        let nextButtonEnabled = false;
        
        // Beƒüenilen fonksiyonlar i√ßin yeni deƒüi≈ükenler
        let savedFunctions = [];
        let currentFunctionData = null;
        
        // JSON dosyasƒ±ndan y√ºklenen fonksiyonlar i√ßin deƒüi≈ükenler
        let jsonFunctions = [];
        let selectedJsonFunctions = [];
        let currentJsonIndex = 0;
        
        // Egzersiz b√∂l√ºm√º i√ßin JSON fonksiyonlarƒ±
        let interactiveJsonFunctions = [];
        let currentInteractiveJsonIndex = 0;
        
        // Sayfa y√ºklendiƒüinde ba≈ülat
        document.addEventListener('DOMContentLoaded', function() {
            // Giri≈ü b√∂l√ºm√º buton event listener'ƒ±
            const startSimulationBtn = document.getElementById('startSimulationBtn');
            startSimulationBtn.addEventListener('click', function() {
                // Giri≈ü b√∂l√ºm√ºn√º gizle ve ana uygulamayƒ± g√∂ster
                document.getElementById('welcomeSection').style.display = 'none';
                document.getElementById('mainApplication').style.display = 'block';
                
                // Canvas ve diƒüer bile≈üenleri ba≈ülat
                initializeApplication();
            });
        });
        
        // Ana uygulamayƒ± ba≈ülat
        function initializeApplication() {
            canvas = document.getElementById('functionChart');
            ctx = canvas.getContext('2d');
            setupCanvas();
            setupEventListeners();
            updateProgressInfo();
            
            // JSON dosyasƒ±nƒ± y√ºkle ve ilk fonksiyonu g√∂ster
            loadJsonFunctions();
        }
        
        // JSON dosyasƒ±ndan fonksiyonlarƒ± y√ºkle
        async function loadJsonFunctions() {
            try {
                const response = await fetch('./fonk2.json');
                if (!response.ok) {
                    throw new Error('JSON dosyasƒ± y√ºklenemedi');
                }
                
                const data = await response.json();
                jsonFunctions = data.functions || [];
                
                if (jsonFunctions.length === 0) {
                    console.error('JSON dosyasƒ±nda fonksiyon bulunamadƒ±');
                    // Fallback olarak rastgele fonksiyon √ºret
                    generateRandomFunction();
                    return;
                }
                
                // 5 rastgele fonksiyon se√ß (simulasyon i√ßin)
                selectRandomJsonFunctions();
                
                // 10 rastgele fonksiyon se√ß (egzersiz i√ßin)
                selectRandomInteractiveJsonFunctions();
                
                // ƒ∞lk fonksiyonu y√ºkle
                loadJsonFunction(0);
                
            } catch (error) {
                console.error('JSON dosyasƒ± y√ºklenirken hata:', error);
                // Fallback olarak rastgele fonksiyon √ºret
                generateRandomFunction();
            }
        }
        
        // 5 rastgele fonksiyon se√ß (simulasyon i√ßin)
        function selectRandomJsonFunctions() {
            selectedJsonFunctions = [];
            const availableIndices = [...Array(jsonFunctions.length).keys()];
            
            // 5 rastgele indeks se√ß
            for (let i = 0; i < 5; i++) {
                if (availableIndices.length === 0) break;
                
                const randomIndex = Math.floor(Math.random() * availableIndices.length);
                const selectedIndex = availableIndices.splice(randomIndex, 1)[0];
                selectedJsonFunctions.push(jsonFunctions[selectedIndex]);
            }
            
            currentJsonIndex = 0;
        }
        
        // 10 rastgele fonksiyon se√ß (egzersiz i√ßin)
        function selectRandomInteractiveJsonFunctions() {
            interactiveJsonFunctions = [];
            const availableIndices = [...Array(jsonFunctions.length).keys()];
            
            // 10 rastgele indeks se√ß
            for (let i = 0; i < 10; i++) {
                if (availableIndices.length === 0) break;
                
                const randomIndex = Math.floor(Math.random() * availableIndices.length);
                const selectedIndex = availableIndices.splice(randomIndex, 1)[0];
                interactiveJsonFunctions.push(jsonFunctions[selectedIndex]);
            }
            
            currentInteractiveJsonIndex = 0;
        }
        
        // JSON'dan se√ßilen fonksiyonu y√ºkle
        function loadJsonFunction(index) {
            if (index >= selectedJsonFunctions.length) {
                // T√ºm simulasyon fonksiyonlarƒ± tamamlandƒ±, interaktif moda ge√ß
                isInteractiveMode = true;
                interactiveFunctionCounter = 0;
                updateProgressInfo();
                generateInteractiveFunction();
                return;
            }
            
            stopAnimation();
            
            const func = selectedJsonFunctions[index];
            currentPoints = func.points || [];
            xIntercepts = func.xIntercepts || [];
            currentGraphType = func.graphType || 'curved';
            
            functionCounter = index + 1;
            updateProgressInfo();
            
            // Artan/azalan analizi i√ßin veri hazƒ±rla
            prepareMonotonicityAnalysis();
            
            updateGraphTitle();
            resetMonotonicityTable();
            
            startDrawAnimation();
        }
        
        // Egzersiz fonksiyonlarƒ± bittiƒüinde yeniden karƒ±≈ütƒ±r
        function reshuffleInteractiveFunctions() {
            if (jsonFunctions.length > 0) {
                selectRandomInteractiveJsonFunctions();
                console.log('Egzersiz fonksiyonlarƒ± yeniden karƒ±≈ütƒ±rƒ±ldƒ±');
            }
        }
        
        // Event listener'larƒ± ayarla
        function setupEventListeners() {
            document.getElementById('generateBtn').addEventListener('click', generateRandomFunction);
            document.getElementById('checkBtn').addEventListener('click', checkAnswer);
            document.getElementById('nextBtn').addEventListener('click', generateRandomFunction);
            window.addEventListener('resize', setupCanvas);
            
            // Touch event optimizasyonlarƒ± - sadece canvas i√ßin
            canvas.addEventListener('touchstart', function(e) {
                e.preventDefault();
            }, { passive: false });
            
            canvas.addEventListener('touchmove', function(e) {
                e.preventDefault();
            }, { passive: false });
        }
        
        // ƒ∞lerleme bilgisini g√ºncelle
        function updateProgressInfo() {
            const progressInfo = document.getElementById('progressInfo');
            const generateBtn = document.getElementById('generateBtn');
            const interactiveControls = document.getElementById('interactiveControls');
            const taskInstructions = document.getElementById('taskInstructions');
            const nextBtn = document.getElementById('nextBtn');
            
            if (!isInteractiveMode) {
                progressInfo.textContent = `Fonksiyon: ${functionCounter}/5`;
                interactiveControls.style.display = 'none';
                taskInstructions.style.display = 'none';
                
                if (functionCounter >= maxFunctions) {
                    generateBtn.disabled = false;
                    generateBtn.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M9 12l2 2 4-4"></path>
                            <circle cx="12" cy="12" r="10"></circle>
                        </svg>
                        Sƒ±ra Sende
                    `;
                    generateBtn.style.background = 'linear-gradient(135deg, #28a745, #20c997)';
                } else {
                    generateBtn.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M9 18l6-6-6-6"></path>
                        </svg>
                        Sonraki Fonksiyon
                    `;
                }
            } else {
                progressInfo.textContent = `Sƒ±ra Sende: ${interactiveFunctionCounter}/${maxInteractiveFunctions}`;
                
                if (interactiveFunctionCounter >= maxInteractiveFunctions) {
                    generateBtn.style.display = 'none';
                    interactiveControls.style.display = 'none';
                    taskInstructions.style.display = 'none';
                    nextBtn.style.display = 'none';
                    
                    // Tamamlandƒ± mesajƒ± g√∂ster
                    const controls = document.querySelector('.controls');
                    controls.innerHTML = `
                        <div style="text-align: center; padding: 20px; background: #d4edda; border-radius: 8px; color: #155724;">
                            <h3>üéâ Tebrikler!</h3>
                            <p>T√ºm egzersizleri ba≈üarƒ±yla tamamladƒ±nƒ±z!</p>
                        </div>
                    `;
                } else {
                    generateBtn.style.display = 'none';
                    interactiveControls.style.display = 'block';
                    taskInstructions.style.display = 'block';
                    nextBtn.style.display = 'flex';
                    nextBtn.disabled = !nextButtonEnabled;
                }
            }
        }
        
        // Canvas boyutlarƒ±nƒ± ayarla
        function setupCanvas() {
            const canvasWrapper = document.querySelector('.canvas-wrapper');
            const width = canvasWrapper.clientWidth;
            const height = canvasWrapper.clientHeight;
            
            // Retina display desteƒüi
            const ratio = window.devicePixelRatio || 1;
            canvas.width = width * ratio;
            canvas.height = height * ratio;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            ctx.scale(ratio, ratio);
            
            if (currentPoints.length > 0) {
                if (isAnimating) {
                    drawCoordinateSystem();
                } else {
                    drawGraph();
                }
            } else {
                drawEmptyGraph();
            }
        }
        
        // Rastgele tam sayƒ± √ºret
        function randomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        
        // X eksenini kesen noktalar √ºret
        function generateXIntercepts() {
            const numIntercepts = randomInt(1, 3);
            const intercepts = [];
            const usedX = new Set();
            
            while (intercepts.length < numIntercepts) {
                const x = randomInt(-10, 10);
                if (!usedX.has(x)) {
                    usedX.add(x);
                    intercepts.push(x);
                }
            }
            
            return intercepts.sort((a, b) => a - b);
        }
        
        // X kesim noktalarƒ±ndan ge√ßen fonksiyon noktalarƒ± √ºret
        function generatePointsFromIntercepts(intercepts) {
            const points = [];
            
            intercepts.forEach(x => {
                points.push({x: x, y: 0});
            });
            
            const additionalPoints = 5 - intercepts.length;
            const usedX = new Set(intercepts);
            
            // √ñnce t√ºm x koordinatlarƒ±nƒ± belirle
            const allXCoords = [...intercepts];
            for (let i = 0; i < additionalPoints; i++) {
                let x;
                let attempts = 0;
                do {
                    x = randomInt(-10, 10);
                    attempts++;
                } while (usedX.has(x) && attempts < 50);
                
                if (usedX.has(x)) {
                    for (let testX = -10; testX <= 10; testX++) {
                        if (!usedX.has(testX)) {
                            x = testX;
                            break;
                        }
                    }
                }
                usedX.add(x);
                allXCoords.push(x);
            }
            
            // X koordinatlarƒ±nƒ± sƒ±rala
            allXCoords.sort((a, b) => a - b);
            
            // Y deƒüerlerini stratejik olarak ata
            for (let i = 0; i < allXCoords.length; i++) {
                const x = allXCoords[i];
                
                // Eƒüer x-intercept ise y=0
                if (intercepts.includes(x)) {
                    continue; // Zaten eklendi
                }
                
                let y;
                
                if (points.length === 0) {
                    // ƒ∞lk nokta rastgele
                    y = randomInt(-8, 8);
                } else if (points.length === 1) {
                    // ƒ∞kinci nokta da nispeten serbest
                    y = randomInt(-8, 8);
                } else {
                    // √ú√ß√ºnc√º ve sonraki noktalar i√ßin ardƒ±≈üƒ±k segment kontrol√º
                    const sortedPoints = [...points].sort((a, b) => a.x - b.x);
                    
                    // Son iki noktayƒ± bul
                    const lastPoint = sortedPoints[sortedPoints.length - 1];
                    const secondLastPoint = sortedPoints[sortedPoints.length - 2];
                    
                    // √ñnceki segmentin eƒüimini hesapla
                    const prevSlope = (lastPoint.y - secondLastPoint.y) / (lastPoint.x - secondLastPoint.x);
                    
                    // Yeni segmentin farklƒ± davranƒ±≈ü sergilemesi i√ßin y deƒüerini belirle
                    if (prevSlope > 0.1) {  // E≈üik deƒüerini d√º≈ü√ºrd√ºk
                        // √ñnceki segment ARTAN ise -> AZALAN veya SABƒ∞T yap
                        if (Math.random() < 0.7) {
                            // %70 ihtimalle azalan
                            y = lastPoint.y - randomInt(3, 8);
                        } else {
                            // %30 ihtimalle sabit
                            y = lastPoint.y + randomInt(-1, 1);
                        }
                    } else if (prevSlope < -0.1) {  // E≈üik deƒüerini d√º≈ü√ºrd√ºk
                        // √ñnceki segment AZALAN ise -> ARTAN veya SABƒ∞T yap
                        if (Math.random() < 0.7) {
                            // %70 ihtimalle artan
                            y = lastPoint.y + randomInt(3, 8);
                        } else {
                            // %30 ihtimalle sabit
                            y = lastPoint.y + randomInt(-1, 1);
                        }
                    } else {
                        // √ñnceki segment SABƒ∞T ise -> ARTAN veya AZALAN yap
                        if (Math.random() < 0.5) {
                            // %50 artan
                            y = lastPoint.y + randomInt(3, 8);
                        } else {
                            // %50 azalan
                            y = lastPoint.y - randomInt(3, 8);
                        }
                    }
                    
                    // Y sƒ±nƒ±rlarƒ±nƒ± kontrol et
                    y = Math.max(-10, Math.min(10, y));
                }
                
                // Y=0 durumunu √∂nle (x-intercept ile karƒ±≈ümasƒ±n)
                if (y === 0) y = Math.random() < 0.5 ? 1 : -1;
                
                points.push({x, y});
            }
            
            return points.sort((a, b) => a.x - b.x);
        }
        
        // Rastgele fonksiyon √ºret
        function generateRandomFunction() {
            if (!isInteractiveMode && functionCounter >= maxFunctions) {
                // ƒ∞nteraktif moda ge√ß
                isInteractiveMode = true;
                interactiveFunctionCounter = 0;
                updateProgressInfo();
                generateInteractiveFunction();
                return;
            }
            
            if (isInteractiveMode && interactiveFunctionCounter >= maxInteractiveFunctions) return;
            
            if (isInteractiveMode) {
                generateInteractiveFunction();
                return;
            }
            
            // Eƒüer JSON fonksiyonlarƒ± mevcutsa onlarƒ± kullan
            if (selectedJsonFunctions.length > 0 && currentJsonIndex < selectedJsonFunctions.length) {
                loadJsonFunction(currentJsonIndex);
                currentJsonIndex++;
                return;
            }
            
            // JSON fonksiyonlarƒ± bittiyse veya yoksa rastgele √ºret
            stopAnimation();
            
            functionCounter++;
            updateProgressInfo();
            
            xIntercepts = generateXIntercepts();
            currentPoints = generatePointsFromIntercepts(xIntercepts);
            
            // Rastgele √ßizgi tipi se√ß - %40 doƒürusal, %60 eƒürisel
            currentGraphType = Math.random() < 0.4 ? 'linear' : 'curved';
            
            // Artan/azalan analizi i√ßin veri hazƒ±rla
            prepareMonotonicityAnalysis();
            
            updateGraphTitle();
            resetMonotonicityTable();
            
            startDrawAnimation();
        }
        
        // Animasyon ba≈ülatma
        function startDrawAnimation() {
            animationProgress = 0;
            isAnimating = true;
            currentAnalysisIndex = 0;
            
            drawCoordinateSystem();
            animateDrawing();
        }
        
        // Animasyonu durdurma
        function stopAnimation() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            isAnimating = false;
            animationProgress = 1;
            currentAnalysisIndex = monotonicityData.length;
            
            if (currentPoints.length > 0) {
                drawGraph();
                
                // ƒ∞nteraktif modda tablo olu≈üturma
                if (isInteractiveMode) {
                    createInteractiveTable();
                } else {
                    completeMonotonicityTable();
                }
            }
        }
        
        // √áizim animasyonu
        function animateDrawing() {
            if (!isAnimating) return;
            
            animationProgress += animationSpeed;
            
            if (animationProgress >= 1) {
                animationProgress = 1;
                isAnimating = false;
                
                // ƒ∞nteraktif modda tablo olu≈üturma
                if (isInteractiveMode) {
                    createInteractiveTable();
                } else {
                    completeMonotonicityTable();
                }
            }
            
            drawCoordinateSystem();
            drawAnimatedContinuousGraph();
            drawAnimatedPoints();
            
            // Normal modda animasyon sƒ±rasƒ±nda tablo g√ºncelle
            if (!isInteractiveMode) {
                updateMonotonicityTableWithAnimation();
            }
            
            if (isAnimating) {
                animationId = requestAnimationFrame(animateDrawing);
            }
        }
        
        // Koordinat sistemini √ßiz
        function drawCoordinateSystem() {
            const width = canvas.style.width ? parseInt(canvas.style.width) : canvas.width;
            const height = canvas.style.height ? parseInt(canvas.style.height) : canvas.height;
            
            const padding = Math.min(width, height) * 0.1;
            const centerX = width / 2;
            const centerY = height / 2;
            // Scale'i -10 ile +10 sayƒ±larƒ± sƒ±ƒüacak ≈üekilde ayarla
            const availableWidth = (width - padding * 2) / 2; // Saƒü tarafƒ±n geni≈üliƒüi
            const availableHeight = (height - padding * 2) / 2; // √úst tarafƒ±n y√ºksekliƒüi
            const scaleX = availableWidth / 10; // X ekseni i√ßin 10 birim scale
            const scaleY = availableHeight / 10; // Y ekseni i√ßin 10 birim scale
            
            ctx.clearRect(0, 0, width, height);
            
            // Grid √ßizgileri √ßiz (ana eksenlerden √∂nce)
            // Mobil optimizasyonu - ekran boyutuna g√∂re grid ayarlarƒ±
            const isMobile = width < 500; // Mobil tespit
            
            // Mobilde daha belirgin grid i√ßin ayarlar
            if (isMobile) {
                ctx.strokeStyle = '#e8e8e8'; // Daha koyu gri
                ctx.lineWidth = 0.8; // Daha kalƒ±n √ßizgi
                ctx.globalAlpha = 0.7; // Daha opak
            } else {
                ctx.strokeStyle = '#e0e0e0'; // Masa√ºst√º i√ßin normal
                ctx.lineWidth = 0.5;
                ctx.globalAlpha = 0.6;
            }
            
            // Dikey grid √ßizgileri
            for (let i = -10; i <= 10; i++) {
                if (i === 0) continue; // Ana Y ekseni atlanacak
                const x = centerX + i * scaleX;
                if (x >= padding && x <= width - padding) {
                    ctx.beginPath();
                    ctx.moveTo(x, padding);
                    ctx.lineTo(x, height - padding);
                    ctx.stroke();
                }
            }
            
            // Yatay grid √ßizgileri
            for (let i = -10; i <= 10; i++) {
                if (i === 0) continue; // Ana X ekseni atlanacak
                const y = centerY - i * scaleY;
                if (y >= padding && y <= height - padding) {
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(width - padding, y);
                    ctx.stroke();
                }
            }
            
            // Grid √ßizimi tamamlandƒ±ktan sonra alpha'yƒ± sƒ±fƒ±rla
            ctx.globalAlpha = 1;
            
            // X ekseni (ana)
            ctx.beginPath();
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.moveTo(padding, centerY);
            ctx.lineTo(width - padding, centerY);
            ctx.stroke();
            
            // Y ekseni (ana)
            ctx.beginPath();
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 2;
            ctx.moveTo(centerX, height - padding);
            ctx.lineTo(centerX, padding);
            ctx.stroke();
            
            // Ok i≈üaretleri
            const arrowSize = Math.min(scaleX, scaleY) * 0.4;
            
            // X ekseni saƒü ok
            ctx.beginPath();
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            const xArrowTip = width - padding;
            ctx.moveTo(xArrowTip - arrowSize, centerY - arrowSize/2);
            ctx.lineTo(xArrowTip, centerY);
            ctx.lineTo(xArrowTip - arrowSize, centerY + arrowSize/2);
            ctx.stroke();
            
            // X ekseni sol ok
            ctx.beginPath();
            const xArrowLeftTip = padding;
            ctx.moveTo(xArrowLeftTip + arrowSize, centerY - arrowSize/2);
            ctx.lineTo(xArrowLeftTip, centerY);
            ctx.lineTo(xArrowLeftTip + arrowSize, centerY + arrowSize/2);
            ctx.stroke();
            
            // Y ekseni yukarƒ± ok
            ctx.beginPath();
            ctx.strokeStyle = '#2c3e50';
            const yArrowTip = padding;
            ctx.moveTo(centerX - arrowSize/2, yArrowTip + arrowSize);
            ctx.lineTo(centerX, yArrowTip);
            ctx.lineTo(centerX + arrowSize/2, yArrowTip + arrowSize);
            ctx.stroke();
            
            // Y ekseni a≈üaƒüƒ± ok
            ctx.beginPath();
            const yArrowBottomTip = height - padding;
            ctx.moveTo(centerX - arrowSize/2, yArrowBottomTip - arrowSize);
            ctx.lineTo(centerX, yArrowBottomTip);
            ctx.lineTo(centerX + arrowSize/2, yArrowBottomTip - arrowSize);
            ctx.stroke();
            
            // Eksen noktalarƒ±
            ctx.fillStyle = '#2c3e50';
            for (let i = -10; i <= 10; i++) {
                if (i === 0) continue;
                const x = centerX + i * scaleX;
                if (x >= padding && x <= width - padding) {
                    ctx.beginPath();
                    ctx.arc(x, centerY, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            for (let i = -10; i <= 10; i++) {
                if (i === 0) continue;
                const y = centerY - i * scaleY;
                if (y >= padding && y <= height - padding) {
                    ctx.beginPath();
                    ctx.arc(centerX, y, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Mobil i√ßin daha k√º√ß√ºk etiketler
            const fontSize = Math.max(8, Math.min(12, width * 0.025));
            ctx.fillStyle = '#2c3e50';
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = 'center';
            
            // X ekseni etiketleri - 1'den 10'a kadar ardƒ±≈üƒ±k
            for (let i = 1; i <= 10; i++) {
                const x = centerX + i * scaleX;
                if (x >= padding && x <= width - padding) {
                    ctx.fillText(i.toString(), x, centerY + fontSize + 3);
                }
            }
            
            // X ekseni negatif etiketler
            for (let i = -10; i <= -1; i++) {
                const x = centerX + i * scaleX;
                if (x >= padding && x <= width - padding) {
                    ctx.fillText(i.toString(), x, centerY + fontSize + 3);
                }
            }
            
            // Y ekseni etiketleri - 1'den 10'a kadar ardƒ±≈üƒ±k
            ctx.textAlign = 'right';
            for (let i = 1; i <= 10; i++) {
                const y = centerY - i * scaleY;
                if (y >= padding && y <= height - padding) {
                    ctx.fillText(i.toString(), centerX - 5, y + fontSize/3);
                }
            }
            
            // Y ekseni negatif etiketler
            for (let i = -10; i <= -1; i++) {
                const y = centerY - i * scaleY;
                if (y >= padding && y <= height - padding) {
                    ctx.fillText(i.toString(), centerX - 5, y + fontSize/3);
                }
            }
            
            ctx.fillText('0', centerX - fontSize, centerY + fontSize + 3);
            
            // Eksen isimleri
            ctx.font = `bold ${fontSize + 2}px Arial`;
            ctx.fillStyle = '#1a2a6c';
            ctx.textAlign = 'center';
            ctx.fillText('x', width - padding + fontSize, centerY - 5);
            ctx.fillText('y', centerX + fontSize, padding - 5);
        }
        
        // Koordinat d√∂n√º≈ü√ºm fonksiyonlarƒ±
        function toCanvasX(x) {
            const width = canvas.style.width ? parseInt(canvas.style.width) : canvas.width;
            const height = canvas.style.height ? parseInt(canvas.style.height) : canvas.height;
            
            const padding = Math.min(width, height) * 0.1;
            
            // Scale'i -10 ile +10 sayƒ±larƒ± sƒ±ƒüacak ≈üekilde ayarla
            const availableWidth = (width - padding * 2) / 2;
            const scaleX = availableWidth / 10;
            return width / 2 + x * scaleX;
        }
        
        function toCanvasY(y) {
            const width = canvas.style.width ? parseInt(canvas.style.width) : canvas.width;
            const height = canvas.style.height ? parseInt(canvas.style.height) : canvas.height;
            
            const padding = Math.min(width, height) * 0.1;
            
            // Scale'i -10 ile +10 sayƒ±larƒ± sƒ±ƒüacak ≈üekilde ayarla
            const availableHeight = (height - padding * 2) / 2;
            const scaleY = availableHeight / 10;
            return height / 2 - y * scaleY;
        }
        
        // Segment rengini belirle
        function getSegmentColor(startPoint, endPoint) {
            // Eƒüer SÔøΩra sende modunda ise tamamen siyah renk kullan
            if (isInteractiveMode) {
                return '#000000'; // Siyah
            }
            
            const deltaY = endPoint.y - startPoint.y;
            const deltaX = endPoint.x - startPoint.x;
            const slope = deltaY / deltaX;
            
            if (slope > 0.01) {  // E≈üik deƒüerini d√º≈ü√ºrd√ºk
                return '#28a745'; // Artan - Ye≈üil
            } else if (slope < -0.01) {  // E≈üik deƒüerini d√º≈ü√ºrd√ºk
                return '#dc3545'; // Azalan - Kƒ±rmƒ±zƒ±  
            } else {
                return '#17a2b8'; // Sabit - Mavi
            }
        }

        // Animasyonlu s√ºrekli grafik √ßizimi
        function drawAnimatedContinuousGraph() {
            if (currentPoints.length === 0) return;
            
            const minX = Math.min(...currentPoints.map(p => p.x));
            const maxX = Math.max(...currentPoints.map(p => p.x));
            const currentMaxX = minX + (maxX - minX) * animationProgress;
            
            ctx.lineWidth = 4;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 2;
            ctx.shadowOffsetX = 1;
            ctx.shadowOffsetY = 1;
            
            if (isInteractiveMode) {
                // ƒ∞nteraktif modda tek mor √ßizgi
                ctx.beginPath();
                ctx.moveTo(toCanvasX(currentPoints[0].x), toCanvasY(currentPoints[0].y));
                
                for (let i = 1; i < currentPoints.length; i++) {
                    const prev = currentPoints[i-1];
                    const current = currentPoints[i];
                    
                    if (prev.x > currentMaxX) break;
                    
                    let endPoint = current;
                    if (current.x > currentMaxX) {
                        const t = (currentMaxX - prev.x) / (current.x - prev.x);
                        endPoint = {
                            x: prev.x + t * (current.x - prev.x),
                            y: prev.y + t * (current.y - prev.y)
                        };
                    }
                    
                    if (currentGraphType === 'linear') {
                        ctx.lineTo(toCanvasX(endPoint.x), toCanvasY(endPoint.y));
                    } else {
                        const controlX1 = toCanvasX(prev.x) + (toCanvasX(endPoint.x) - toCanvasX(prev.x)) * 0.3;
                        const controlY1 = toCanvasY(prev.y);
                        const controlX2 = toCanvasX(prev.x) + (toCanvasX(endPoint.x) - toCanvasX(prev.x)) * 0.7;
                        const controlY2 = toCanvasY(endPoint.y);
                        ctx.bezierCurveTo(controlX1, controlY1, controlX2, controlY2, toCanvasX(endPoint.x), toCanvasY(endPoint.y));
                    }
                    
                    if (current.x > currentMaxX) break;
                }
                ctx.strokeStyle = '#9C27B0'; // Mor renk
                ctx.stroke();
            } else {
                // Normal modda renkli segmentler
                for (let i = 1; i < currentPoints.length; i++) {
                    const prev = currentPoints[i-1];
                    const current = currentPoints[i];
                    
                    if (prev.x > currentMaxX) break;
                    
                    let endPoint = current;
                    if (current.x > currentMaxX) {
                        const t = (currentMaxX - prev.x) / (current.x - prev.x);
                        endPoint = {
                            x: prev.x + t * (current.x - prev.x),
                            y: prev.y + t * (current.y - prev.y)
                        };
                    }
                    
                    ctx.strokeStyle = getSegmentColor(prev, endPoint);
                    ctx.beginPath();
                    ctx.moveTo(toCanvasX(prev.x), toCanvasY(prev.y));
                    
                    if (currentGraphType === 'linear') {
                        ctx.lineTo(toCanvasX(endPoint.x), toCanvasY(endPoint.y));
                    } else {
                        const controlX1 = toCanvasX(prev.x) + (toCanvasX(endPoint.x) - toCanvasX(prev.x)) * 0.3;
                        const controlY1 = toCanvasY(prev.y);
                        const controlX2 = toCanvasX(prev.x) + (toCanvasX(endPoint.x) - toCanvasX(prev.x)) * 0.7;
                        const controlY2 = toCanvasY(endPoint.y);
                        ctx.bezierCurveTo(controlX1, controlY1, controlX2, controlY2, toCanvasX(endPoint.x), toCanvasY(endPoint.y));
                    }
                    ctx.stroke();
                    
                    if (current.x > currentMaxX) break;
                }
            }
            
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }
        
        // Animasyonlu nokta √ßizimi
        function drawAnimatedPoints() {
            if (currentPoints.length === 0) return;
            
            const pointColors = ['#FF5252', '#FF9800', '#4CAF50', '#2196F3', '#9C27B0'];
            const minX = Math.min(...currentPoints.map(p => p.x));
            const maxX = Math.max(...currentPoints.map(p => p.x));
            const currentMaxX = minX + (maxX - minX) * animationProgress;
            
            // X kesim noktalarƒ±nƒ± √ßiz
            xIntercepts.forEach(x => {
                if (x <= currentMaxX) {
                    const cx = toCanvasX(x);
                    const cy = toCanvasY(0);
                    
                    ctx.beginPath();
                    ctx.fillStyle = 'rgba(220, 53, 69, 0.3)';
                    ctx.arc(cx + 1, cy + 1, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.arc(cx, cy, 5, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.fillStyle = isInteractiveMode ? '#9C27B0' : '#dc3545';
                    ctx.arc(cx, cy, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // Diƒüer noktalarƒ± √ßiz
            currentPoints.forEach((point, index) => {
                if (point.x > currentMaxX || point.y === 0) return;
                
                const cx = toCanvasX(point.x);
                const cy = toCanvasY(point.y);
                const pointProgress = Math.min(1, Math.max(0, (currentMaxX - point.x + 1) / 1));
                const alpha = Math.min(1, pointProgress * 2);
                
                if (alpha <= 0) return;
                
                ctx.globalAlpha = alpha * 0.2;
                ctx.beginPath();
                ctx.fillStyle = 'rgba(0, 0, 0, 1)';
                ctx.arc(cx + 1, cy + 1, 4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.arc(cx, cy, 4, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.fillStyle = isInteractiveMode ? '#9C27B0' : pointColors[index];
                ctx.arc(cx, cy, 4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.globalAlpha = 1;
            });
        }
        
        // Normal grafik √ßizimi (animasyonsuz)
        function drawGraph() {
            drawCoordinateSystem();
            drawContinuousGraph();
            drawXIntercepts();
            drawPoints();
        }
        
        // S√ºrekli grafik √ßiz
        function drawContinuousGraph() {
            if (currentPoints.length === 0) return;
            ctx.lineWidth = 4;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 2;
            ctx.shadowOffsetX = 1;
            ctx.shadowOffsetY = 1;

            if (isInteractiveMode) {
                // ƒ∞nteraktif modda tek mor √ßizgi
                ctx.beginPath();
                ctx.moveTo(toCanvasX(currentPoints[0].x), toCanvasY(currentPoints[0].y));
                for (let i = 1; i < currentPoints.length; i++) {
                    const prev = currentPoints[i-1];
                    const current = currentPoints[i];
                    if (currentGraphType === 'linear') {
                        ctx.lineTo(toCanvasX(current.x), toCanvasY(current.y));
                    } else {
                        // Bezier eƒürisi ile yumu≈üak ge√ßi≈ü
                        const controlX1 = toCanvasX(prev.x) + (toCanvasX(current.x) - toCanvasX(prev.x)) * 0.3;
                        const controlY1 = toCanvasY(prev.y);
                        const controlX2 = toCanvasX(prev.x) + (toCanvasX(current.x) - toCanvasX(prev.x)) * 0.7;
                        const controlY2 = toCanvasY(current.y);
                        ctx.bezierCurveTo(controlX1, controlY1, controlX2, controlY2, toCanvasX(current.x), toCanvasY(current.y));
                    }
                }
                ctx.strokeStyle = '#9C27B0'; // Mor renk
                ctx.stroke();
            } else {
                // Normal modda renkli segmentler ama yine birle≈üik
                for (let i = 1; i < currentPoints.length; i++) {
                    const prev = currentPoints[i-1];
                    const current = currentPoints[i];
                    
                    ctx.strokeStyle = getSegmentColor(prev, current);
                    ctx.beginPath();
                    ctx.moveTo(toCanvasX(prev.x), toCanvasY(prev.y));
                    
                    if (currentGraphType === 'linear') {
                        ctx.lineTo(toCanvasX(current.x), toCanvasY(current.y));
                    } else {
                        const controlX1 = toCanvasX(prev.x) + (toCanvasX(current.x) - toCanvasX(prev.x)) * 0.3;
                        const controlY1 = toCanvasY(prev.y);
                        const controlX2 = toCanvasX(prev.x) + (toCanvasX(current.x) - toCanvasX(prev.x)) * 0.7;
                        const controlY2 = toCanvasY(current.y);
                        ctx.bezierCurveTo(controlX1, controlY1, controlX2, controlY2, toCanvasX(current.x), toCanvasY(current.y));
                    }
                    ctx.stroke();
                }
            }

            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }
        
        // X kesim noktalarƒ±nƒ± √ßiz
        function drawXIntercepts() {
            xIntercepts.forEach(x => {
                const cx = toCanvasX(x);
                const cy = toCanvasY(0);
                
                ctx.beginPath();
                ctx.fillStyle = 'rgba(220, 53, 69, 0.3)';
                ctx.arc(cx + 1, cy + 1, 5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.arc(cx, cy, 5, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.fillStyle = isInteractiveMode ? '#9C27B0' : '#dc3545';
                ctx.arc(cx, cy, 5, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        // Noktalarƒ± √ßiz
        function drawPoints() {
            const pointColors = ['#FF5252', '#FF9800', '#4CAF50', '#2196F3', '#9C27B0'];
            // T√ºm noktalarƒ± birle≈üim noktalarƒ±na yerle≈ütir
            currentPoints.forEach((point, index) => {
                const cx = toCanvasX(point.x);
                const cy = toCanvasY(point.y);
                ctx.beginPath();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.arc(cx + 1, cy + 1, 4, 0, Math.PI * 2);
                ctx.fill();

                ctx.beginPath();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.arc(cx, cy, 4, 0, Math.PI * 2);
                ctx.stroke();

                ctx.beginPath();
                ctx.fillStyle = isInteractiveMode ? '#9C27B0' : pointColors[index % pointColors.length];
                ctx.arc(cx, cy, 4, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        // Bo≈ü grafik √ßiz
        function drawEmptyGraph() {
            drawCoordinateSystem();
        }
        
        // Grafik ba≈ülƒ±ƒüƒ±nƒ± g√ºncelle
        function updateGraphTitle() {
            const graphTitleElement = document.getElementById('graphTitle');
            if (!graphTitleElement) {
                // Element yoksa hi√ßbir ≈üey yapma
                return;
            }
            
            let titleText = '';
            if (!isInteractiveMode) {
                titleText = ``; // Bo≈ü ba≈ülƒ±k
            } else {
                const modeText = interactiveFunctionCounter > 5 ? 'Aralƒ±k Yazma' : 'Artan/Azalan Se√ßme';
                titleText = `ƒ∞nteraktif Egzersiz #${interactiveFunctionCounter} - ${modeText}`;
            }
            
            graphTitleElement.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#1a2a6c" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 3v18h18"></path>
                    <path d="M19 9l-5 5-4-4-3 3"></path>
                </svg>
                ${titleText}
            `;
        }

        // Artan/Azalan analizi i√ßin veri hazƒ±rlama
        function prepareMonotonicityAnalysis() {
            monotonicityData = [];
            criticalPoints = [];
            
            if (currentPoints.length < 2) return;
            
            // Noktalarƒ± x deƒüerine g√∂re sƒ±rala
            const sortedPoints = [...currentPoints].sort((a, b) => a.x - b.x);
            
            for (let i = 0; i < sortedPoints.length - 1; i++) {
                const p1 = sortedPoints[i];
                const p2 = sortedPoints[i + 1];
                
                const deltaX = p2.x - p1.x;
                const deltaY = p2.y - p1.y;
                const slope = deltaY / deltaX;
                
                let status = 'constant';
                let statusText = 'SABƒ∞T';
                let trendIcon = 'trend-flat';
                
                if (slope > 0.01) {  // E≈üik deƒüerini d√º≈ü√ºrd√ºk
                    status = 'increasing';
                    statusText = 'ARTAN';
                    trendIcon = 'trend-up';
                } else if (slope < -0.01) {  // E≈üik deƒüerini d√º≈ü√ºrd√ºk
                    status = 'decreasing';
                    statusText = 'AZALAN';
                    trendIcon = 'trend-down';
                }
                
                monotonicityData.push({
                    startX: p1.x,
                    endX: p2.x,
                    interval: `[${p1.x}, ${p2.x}]`,
                    status: status,
                    statusText: statusText,
                    trendIcon: trendIcon,
                    slope: slope.toFixed(2)
                });
            }
        }

        // Artan/azalan tablosunu sƒ±fƒ±rla
        function resetMonotonicityTable() {
            const tableBody = document.getElementById('monotonicityTableBody');
            
            if (isInteractiveMode) {
                tableBody.innerHTML = `
                    <tr>
                        <td colspan="100%" style="text-align: center; padding: 15px; color: #666;">
                            Grafik √ßizimi tamamlandƒ±ktan sonra SÔøΩra sende tablo burada g√∂r√ºnt√ºlenecektir...
                        </td>
                    </tr>
                `;
            } else {
                tableBody.innerHTML = `
                    <tr>
                        <td colspan="100%" style="text-align: center; padding: 15px; color: #666;">
                            Analiz ba≈ülƒ±yor...
                        </td>
                    </tr>
                `;
            }
            
            const progressIndicator = document.getElementById('tableProgressIndicator');
            progressIndicator.style.width = '0%';
            
            const analysisSummary = document.getElementById('analysisSummary');
            analysisSummary.innerHTML = '<strong>üìä Analiz √ñzeti:</strong> Animasyon ba≈üladƒ±ƒüƒ±nda dinamik olarak g√ºncellenecektir.';
            
            // Aralƒ±k analizini gizle
            const intervalAnalysis = document.getElementById('intervalAnalysis');
            intervalAnalysis.style.display = 'none';
        }

        // Animasyonla senkronize tablo g√ºncelleme
        function updateMonotonicityTableWithAnimation() {
            if (monotonicityData.length === 0) return;
            
            const minX = Math.min(...currentPoints.map(p => p.x));
            const maxX = Math.max(...currentPoints.map(p => p.x));
            const currentMaxX = minX + (maxX - minX) * animationProgress;
            
            // Hangi aralƒ±klarƒ±n g√∂sterilmesi gerektiƒüini belirle
            const visibleIntervals = monotonicityData.filter(data => data.startX <= currentMaxX);
            
            if (visibleIntervals.length > 0 && visibleIntervals.length !== currentAnalysisIndex) {
                const tableBody = document.getElementById('monotonicityTableBody');
                
                // Tablo i√ßeriƒüini temizle
                tableBody.innerHTML = '';
                
                // Aralƒ±k satƒ±rƒ±nƒ± olu≈ütur
                const intervalRow = document.createElement('tr');
                intervalRow.className = 'animated-row';
                
                // Durum satƒ±rƒ±nƒ± olu≈ütur
                const statusRow = document.createElement('tr');
                statusRow.className = 'animated-row';
                
                visibleIntervals.forEach((data, index) => {
                    // Aralƒ±k h√ºcresi
                    const intervalCell = document.createElement('td');
                    intervalCell.className = 'interval-row';
                    intervalCell.textContent = data.interval;
                    intervalRow.appendChild(intervalCell);
                    
                    // Durum h√ºcresi
                    const statusCell = document.createElement('td');
                    statusCell.className = `status-row ${data.status}`;
                    statusCell.innerHTML = `
                        <span class="trend-icon ${data.trendIcon}"></span>
                        ${data.statusText}
                    `;
                    statusRow.appendChild(statusCell);
                });
                
                tableBody.appendChild(intervalRow);
                tableBody.appendChild(statusRow);
                
                currentAnalysisIndex = visibleIntervals.length;
                updateAnalysisSummary(visibleIntervals);
            }
            
            // Progress indicator g√ºncelle
            const progressIndicator = document.getElementById('tableProgressIndicator');
            progressIndicator.style.width = (animationProgress * 100) + '%';
        }

        // Tabloyu tamamla
        function completeMonotonicityTable() {
            if (monotonicityData.length === 0) return;
            
            currentAnalysisIndex = monotonicityData.length;
            
            const tableBody = document.getElementById('monotonicityTableBody');
            tableBody.innerHTML = '';
            
            // Aralƒ±k satƒ±rƒ±nƒ± olu≈ütur
            const intervalRow = document.createElement('tr');
            
            // Sol etiket h√ºcresi - "x"
            const intervalLabelCell = document.createElement('td');
            intervalLabelCell.className = 'interval-row';
            intervalLabelCell.textContent = 'x';
            intervalLabelCell.style.backgroundColor = '#2c3e50';
            intervalLabelCell.style.color = 'white';
            intervalLabelCell.style.fontWeight = 'bold';
            intervalLabelCell.style.fontSize = '12px';
            intervalLabelCell.style.padding = '8px 6px';
            intervalLabelCell.style.textAlign = 'center';
            intervalLabelCell.style.minWidth = '40px';
            intervalRow.appendChild(intervalLabelCell);
            
            // Durum satƒ±rƒ±nƒ± olu≈ütur
            const statusRow = document.createElement('tr');
            
            // Sol etiket h√ºcresi - "f(x)"
            const statusLabelCell = document.createElement('td');
            statusLabelCell.className = 'status-row';
            statusLabelCell.textContent = 'f(x)';
            statusLabelCell.style.backgroundColor = '#34495e';
            statusLabelCell.style.color = 'white';
            statusLabelCell.style.fontWeight = 'bold';
            statusLabelCell.style.fontSize = '12px';
            statusLabelCell.style.padding = '8px 6px';
            statusLabelCell.style.textAlign = 'center';
            statusLabelCell.style.minWidth = '40px';
            statusRow.appendChild(statusLabelCell);
            
            monotonicityData.forEach((data, index) => {
                // Aralƒ±k h√ºcresi
                const intervalCell = document.createElement('td');
                intervalCell.className = 'interval-row';
                intervalCell.textContent = data.interval;
                intervalRow.appendChild(intervalCell);
                
                // Durum h√ºcresi
                const statusCell = document.createElement('td');
                statusCell.className = `status-row ${data.status}`;
                statusCell.innerHTML = `
                    <span class="trend-icon ${data.trendIcon}"></span>
                    ${data.statusText}
                `;
                statusRow.appendChild(statusCell);
            });
            
            tableBody.appendChild(intervalRow);
            tableBody.appendChild(statusRow);
            
            updateAnalysisSummary(monotonicityData);
            
            const progressIndicator = document.getElementById('tableProgressIndicator');
            progressIndicator.style.width = '100%';
        }

        // ƒ∞nteraktif fonksiyon √ºret
        function generateInteractiveFunction() {
            if (interactiveFunctionCounter >= maxInteractiveFunctions) return;
            
            stopAnimation();
            
            interactiveFunctionCounter++;
            isAnswerCorrect = false;
            nextButtonEnabled = false;
            
            // √ñnceki geri bildirim mesajlarƒ±nƒ± temizle
            const feedbackMessage = document.getElementById('feedbackMessage');
            feedbackMessage.style.display = 'none';
            
            // G√∂rev talimatlarƒ±nƒ± g√∂ster
            const taskInstructions = document.getElementById('taskInstructions');
            taskInstructions.style.display = 'block';
            
            updateProgressInfo();
            
            // JSON fonksiyonlarƒ±nƒ± kullan eƒüer varsa
            if (interactiveJsonFunctions.length > 0 && currentInteractiveJsonIndex < interactiveJsonFunctions.length) {
                const func = interactiveJsonFunctions[currentInteractiveJsonIndex];
                currentPoints = func.points || [];
                xIntercepts = func.xIntercepts || [];
                currentGraphType = func.graphType || 'curved';
                currentInteractiveJsonIndex++;
            } else if (interactiveJsonFunctions.length > 0 && currentInteractiveJsonIndex >= interactiveJsonFunctions.length) {
                // JSON fonksiyonlarƒ± bitti, yeniden karƒ±≈ütƒ±r
                reshuffleInteractiveFunctions();
                const func = interactiveJsonFunctions[0];
                currentPoints = func.points || [];
                xIntercepts = func.xIntercepts || [];
                currentGraphType = func.graphType || 'curved';
                currentInteractiveJsonIndex = 1;
            } else {
                // Fallback: rastgele fonksiyon √ºret
                xIntercepts = generateXIntercepts();
                currentPoints = generatePointsFromIntercepts(xIntercepts);
                currentGraphType = Math.random() < 0.4 ? 'linear' : 'curved';
            }
            
            prepareMonotonicityAnalysis();
            currentInteractiveData = [...monotonicityData];
            
            updateGraphTitle();
            createInteractiveTable();
            
            // Yeni egzersizde aralƒ±k analizini gizle
            const intervalAnalysis = document.getElementById('intervalAnalysis');
            intervalAnalysis.style.display = 'none';
            
            startDrawAnimation();
        }
        
        // ƒ∞nteraktif tablo olu≈ütur
        function createInteractiveTable() {
            console.log('Creating interactive table, mode:', isInteractiveMode, 'counter:', interactiveFunctionCounter);
            console.log('Current interactive data:', currentInteractiveData);
            
            const tableBody = document.getElementById('monotonicityTableBody');
            tableBody.innerHTML = '';
            
            if (!currentInteractiveData || currentInteractiveData.length === 0) {
                console.error('No interactive data available');
                tableBody.innerHTML = `
                    <tr>
                        <td colspan="100%" style="text-align: center; padding: 15px; color: #dc3545;">
                            Hata: Analiz verileri bulunamadƒ±!
                        </td>
                    </tr>
                `;
                return;
            }
            
            const isIntervalMode = interactiveFunctionCounter > 5; // ƒ∞lk 5'i artan/azalan, sonraki 5'i aralƒ±k
            console.log('Is interval mode:', isIntervalMode);
            
            if (isIntervalMode) {
                // Aralƒ±k yazma modu - kullanƒ±cƒ± hem aralƒ±ƒüƒ± hem durumu yazacak
                createIntervalWritingTable(tableBody);
            } else {
                // Artan/Azalan se√ßme modu - sadece durumu se√ßecek
                createStatusSelectingTable(tableBody);
            }
            
            updateInteractiveAnalysisSummary();
            console.log('Interactive table creation completed');
        }
        
        // Durum se√ßme tablosu olu≈ütur
        function createStatusSelectingTable(tableBody) {
            console.log('Creating status selecting table for', currentInteractiveData.length, 'intervals');
            
            // Aralƒ±k satƒ±rƒ±nƒ± olu≈ütur (√∂nceden doldurulmu≈ü)
            const intervalRow = document.createElement('tr');
            intervalRow.className = 'interval-row-header';
            
            // Sol etiket h√ºcresi - "ax"
            const intervalLabelCell = document.createElement('td');
            intervalLabelCell.className = 'interval-row';
            intervalLabelCell.textContent = 'x';
            intervalLabelCell.style.backgroundColor = '#2c3e50';
            intervalLabelCell.style.color = 'white';
            intervalLabelCell.style.fontWeight = 'bold';
            intervalLabelCell.style.fontSize = '12px';
            intervalLabelCell.style.padding = '8px 6px';
            intervalLabelCell.style.textAlign = 'center';
            intervalLabelCell.style.minWidth = '40px';
            intervalRow.appendChild(intervalLabelCell);
            
            // Durum satƒ±rƒ±nƒ± olu≈ütur (kullanƒ±cƒ± doldurmasƒ± i√ßin)
            const statusRow = document.createElement('tr');
            statusRow.className = 'status-row-interactive';
            
            // Sol etiket h√ºcresi - "f(x)"
            const statusLabelCell = document.createElement('td');
            statusLabelCell.className = 'status-row';
            statusLabelCell.textContent = 'f(x)';
            statusLabelCell.style.backgroundColor = '#34495e';
            statusLabelCell.style.color = 'white';
            statusLabelCell.style.fontWeight = 'bold';
            statusLabelCell.style.fontSize = '12px';
            statusLabelCell.style.padding = '8px 6px';
            statusLabelCell.style.textAlign = 'center';
            statusLabelCell.style.minWidth = '40px';
            statusRow.appendChild(statusLabelCell);
            
            currentInteractiveData.forEach((data, index) => {
                console.log(`Creating cells for interval ${index}:`, data.interval, data.status);
                
                // Aralƒ±k h√ºcresi - √∂nceden doldurulmu≈ü
                const intervalCell = document.createElement('td');
                intervalCell.className = 'interval-row';
                intervalCell.textContent = data.interval;
                intervalCell.style.backgroundColor = '#ff9800';
                intervalCell.style.color = 'white';
                intervalCell.style.fontWeight = 'bold';
                intervalCell.style.fontSize = '11px';
                intervalCell.style.padding = '8px 4px';
                intervalCell.style.textAlign = 'center';
                intervalRow.appendChild(intervalCell);
                
                // Durum h√ºcresi - kullanƒ±cƒ± dolduracak
                const statusCell = document.createElement('td');
                statusCell.className = 'status-row interactive-cell';
                statusCell.style.padding = '5px 2px';
                statusCell.style.backgroundColor = '#f8f9fa';
                statusCell.innerHTML = `
                    <select id="status_${index}" 
                            style="width: 100%; border: 1px solid #ccc; border-radius: 3px; padding: 4px; font-size: 11px; background: white;"
                            >
                        <option value="">-- Se√ßin --</option>
                        <option value="increasing">ARTAN</option>
                        <option value="decreasing">AZALAN</option>
                        <option value="constant">SABƒ∞T</option>
                    </select>
                `;
                statusRow.appendChild(statusCell);
            });
            
            tableBody.appendChild(intervalRow);
            tableBody.appendChild(statusRow);
            
            console.log('Status selecting table created successfully');
        }
        
        // Aralƒ±k yazma tablosu olu≈ütur
        function createIntervalWritingTable(tableBody) {
            console.log('Creating interval writing table for', currentInteractiveData.length, 'intervals');
            
            // Aralƒ±k satƒ±rƒ±nƒ± olu≈ütur (kullanƒ±cƒ± doldurmasƒ± i√ßin)
            const intervalRow = document.createElement('tr');
            intervalRow.className = 'interval-row-interactive';
            
            // Sol etiket h√ºcresi - "ax"
            const intervalLabelCell = document.createElement('td');
            intervalLabelCell.className = 'interval-row';
            intervalLabelCell.textContent = 'x';
            intervalLabelCell.style.backgroundColor = '#2c3e50';
            intervalLabelCell.style.color = 'white';
            intervalLabelCell.style.fontWeight = 'bold';
            intervalLabelCell.style.fontSize = '12px';
            intervalLabelCell.style.padding = '8px 6px';
            intervalLabelCell.style.textAlign = 'center';
            intervalLabelCell.style.minWidth = '40px';
            intervalRow.appendChild(intervalLabelCell);
            
            // Durum satƒ±rƒ±nƒ± olu≈ütur (kullanƒ±cƒ± doldurmasƒ± i√ßin)
            const statusRow = document.createElement('tr');
            statusRow.className = 'status-row-interactive';
            
            // Sol etiket h√ºcresi - "f(x)"
            const statusLabelCell = document.createElement('td');
            statusLabelCell.className = 'status-row';
            statusLabelCell.textContent = 'f(x)';
            statusLabelCell.style.backgroundColor = '#34495e';
            statusLabelCell.style.color = 'white';
            statusLabelCell.style.fontWeight = 'bold';
            statusLabelCell.style.fontSize = '12px';
            statusLabelCell.style.padding = '8px 6px';
            statusLabelCell.style.textAlign = 'center';
            statusLabelCell.style.minWidth = '40px';
            statusRow.appendChild(statusLabelCell);
            
            currentInteractiveData.forEach((data, index) => {
                console.log(`Creating input cells for interval ${index}:`, data.interval, data.status);
                
                // Aralƒ±k h√ºcresi - kullanƒ±cƒ± dolduracak
                const intervalCell = document.createElement('td');
                intervalCell.className = 'interval-row interactive-cell';
                intervalCell.style.backgroundColor = '#fff3e0';
                intervalCell.style.padding = '5px 2px';
                intervalCell.innerHTML = `
                    <input type="text" 
                           id="interval_${index}" 
                           placeholder="[a,b]" 
                           style="width: 100%; border: 1px solid #ccc; border-radius: 3px; padding: 4px; font-size: 11px; text-align: center; background: white;">
                `;
                intervalRow.appendChild(intervalCell);
                
                // Durum h√ºcresi - kullanƒ±cƒ± dolduracak
                const statusCell = document.createElement('td');
                statusCell.className = 'status-row interactive-cell';
                statusCell.style.padding = '5px 2px';
                statusCell.style.backgroundColor = '#f8f9fa';
                statusCell.innerHTML = `
                    <select id="status_${index}" 
                            style="width: 100%; border: 1px solid #ccc; border-radius: 3px; padding: 4px; font-size: 11px; background: white;"
                            >
                        <option value="">-- Se√ßin --</option>
                        <option value="increasing">ARTAN</option>
                        <option value="decreasing">AZALAN</option>
                        <option value="constant">SABƒ∞T</option>
                    </select>
                `;
                statusRow.appendChild(statusCell);
            });
            
            tableBody.appendChild(intervalRow);
            tableBody.appendChild(statusRow);
            
            console.log('Interval writing table created successfully');
        }
        
        // Cevaplarƒ± kontrol et
        function checkAnswer() {
            const isIntervalMode = interactiveFunctionCounter > 5;
            let allFilled = true;
            let allCorrect = true;
            const feedbackMessage = document.getElementById('feedbackMessage');
            
            // T√ºm giri≈ü alanlarƒ±nƒ± kontrol et
            currentInteractiveData.forEach((data, index) => {
                let userIntervalAnswer = '';
                let userStatusAnswer = '';
                
                if (isIntervalMode) {
                    // Aralƒ±k yazma modu
                    const intervalInput = document.getElementById(`interval_${index}`);
                    const statusSelect = document.getElementById(`status_${index}`);
                    
                    if (intervalInput && statusSelect) {
                        userIntervalAnswer = intervalInput.value.trim();
                        userStatusAnswer = statusSelect.value;
                        
                        if (!userIntervalAnswer || !userStatusAnswer) {
                            allFilled = false;
                            return;
                        }
                        
                        // Aralƒ±k kontrol√º
                        const cleanUserInterval = userIntervalAnswer.replace(/\s/g, '');
                        const cleanCorrectInterval = data.interval.replace(/\s/g, '');
                        const intervalCorrect = cleanUserInterval === cleanCorrectInterval;
                        
                        // Durum kontrol√º
                        const statusCorrect = userStatusAnswer === data.status;
                        
                        // G√∂rsel geri bildirim
                        const intervalCell = intervalInput.parentElement;
                        const statusCell = statusSelect.parentElement;
                        
                        if (intervalCorrect) {
                            intervalCell.style.backgroundColor = '#d4edda';
                            intervalCell.style.border = '2px solid #28a745';
                        } else {
                            intervalCell.style.backgroundColor = '#f8d7da';
                            intervalCell.style.border = '2px solid #dc3545';
                            allCorrect = false;
                        }
                        
                        if (statusCorrect) {
                            statusCell.style.backgroundColor = '#d4edda';
                            statusCell.style.border = '2px solid #28a745';
                        } else {
                            statusCell.style.backgroundColor = '#f8d7da';
                            statusCell.style.border = '2px solid #dc3545';
                            allCorrect = false;
                        }
                    }
                } else {
                    // Durum se√ßme modu
                    const statusSelect = document.getElementById(`status_${index}`);
                    
                    if (statusSelect) {
                        userStatusAnswer = statusSelect.value;
                        
                        if (!userStatusAnswer) {
                            allFilled = false;
                            return;
                        }
                        
                        const statusCorrect = userStatusAnswer === data.status;
                        const statusCell = statusSelect.parentElement;
                        
                        if (statusCorrect) {
                            statusCell.style.backgroundColor = '#d4edda';
                            statusCell.style.border = '2px solid #28a745';
                        } else {
                            statusCell.style.backgroundColor = '#f8d7da';
                            statusCell.style.border = '2px solid #dc3545';
                            allCorrect = false;
                        }
                    }
                }
            });
            
            // Geri bildirim mesajƒ±nƒ± g√∂ster
            feedbackMessage.style.display = 'block';
            
            if (!allFilled) {
                feedbackMessage.innerHTML = `
                    <strong>üìù Devam edin...</strong><br>
                    L√ºtfen t√ºm alanlarƒ± doldurunuz.
                `;
                feedbackMessage.style.backgroundColor = '#fff3cd';
                feedbackMessage.style.color = '#856404';
                feedbackMessage.style.border = '1px solid #ffeaa7';
                isAnswerCorrect = false;
                nextButtonEnabled = false;
            } else if (allCorrect) {
                feedbackMessage.innerHTML = `
                    <strong>üéâ M√ºkemmel!</strong><br>
                    T√ºm cevaplarƒ±nƒ±z doƒüru! Bir sonraki soruya ge√ßebilirsiniz.
                `;
                feedbackMessage.style.backgroundColor = '#d4edda';
                feedbackMessage.style.color = '#155724';
                feedbackMessage.style.border = '1px solid #c3e6cb';
                isAnswerCorrect = true;
                nextButtonEnabled = true;
                
                // Doƒüru cevap verildikten sonra en geni≈ü aralƒ±k analizini g√∂ster
                calculateIntervalSets(currentInteractiveData);
            } else {
                feedbackMessage.innerHTML = `
                    <strong>‚ö†Ô∏è Tekrar deneyin!</strong><br>
                    Bazƒ± cevaplarƒ±nƒ±z yanlƒ±≈ü. Kƒ±rmƒ±zƒ± i≈üaretli alanlarƒ± kontrol ediniz.
                `;
                feedbackMessage.style.backgroundColor = '#f8d7da';
                feedbackMessage.style.color = '#721c24';
                feedbackMessage.style.border = '1px solid #f5c6cb';
                isAnswerCorrect = false;
                nextButtonEnabled = false;
            }
            
            updateProgressInfo();
        }
        
        // ƒ∞nteraktif analiz √∂zetini g√ºncelle
        function updateInteractiveAnalysisSummary() {
            const analysisSummary = document.getElementById('analysisSummary');
            const isIntervalMode = interactiveFunctionCounter > 5;
            
            if (isIntervalMode) {
                analysisSummary.innerHTML = `
                    <strong>üìù Egzersiz ${interactiveFunctionCounter} - Aralƒ±k Yazma:</strong><br>
                    Aralƒ±klarƒ± ve durumlarƒ± (ARTAN/AZALAN/SABƒ∞T) doldurun, sonra "Kontrol Et" butonuna tƒ±klayƒ±n.
                `;
            } else {
                analysisSummary.innerHTML = `
                    <strong>üìù Egzersiz ${interactiveFunctionCounter} - Durum Se√ßme:</strong><br>
                    Her aralƒ±k i√ßin ARTAN, AZALAN veya SABƒ∞T durumunu se√ßin, sonra "Kontrol Et" butonuna tƒ±klayƒ±n.
                `;
            }
            
            analysisSummary.style.backgroundColor = '#e3f2fd';
            analysisSummary.style.color = '#1565c0';
            analysisSummary.style.border = '1px solid #90caf9';
            
            // G√∂rev talimatlarƒ±nƒ± g√ºncelle
            updateTaskInstructions();
            
            // ƒ∞nteraktif modda ba≈ülangƒ±√ßta aralƒ±k analizini gizle
            const intervalAnalysis = document.getElementById('intervalAnalysis');
            intervalAnalysis.style.display = 'none';
        }
        
        // G√∂rev talimatlarƒ±nƒ± g√ºncelle
        function updateTaskInstructions() {
            const taskContent = document.getElementById('taskContent');
            const isIntervalMode = interactiveFunctionCounter > 5;
            
            if (isIntervalMode) {
                taskContent.innerHTML = `
                    <div style="margin-bottom: 12px;">
                        <strong style="color: #dc3545;">üìê Aralƒ±k Yazma Modu</strong>
                    </div>
                    <ul style="margin: 0; padding-left: 20px; list-style-type: none;">
                        <li style="margin-bottom: 8px;">
                            <span style="color: #28a745; font-weight: bold;">1Ô∏è‚É£</span> 
                            Yukarƒ±daki <strong>mor fonksiyon grafiƒüini</strong> inceleyiniz
                        </li>
                        <li style="margin-bottom: 8px;">
                            <span style="color: #28a745; font-weight: bold;">2Ô∏è‚É£</span> 
                            Tablodaki <strong>bo≈ü aralƒ±k kutularƒ±na</strong> fonksiyonun monotonluk aralƒ±klarƒ±nƒ± yazƒ±nƒ±z<br>
                            <small style="color: #6c757d; margin-left: 20px;">√ñrnek: [-3, 1], [1, 4] ≈üeklinde</small>
                        </li>
                        <li style="margin-bottom: 8px;">
                            <span style="color: #28a745; font-weight: bold;">3Ô∏è‚É£</span> 
                            Her aralƒ±k i√ßin <strong>a√ßƒ±lƒ±r men√ºden</strong> durumu se√ßiniz:
                            <ul style="margin-top: 4px; margin-left: 15px; list-style-type: disc;">
                                <li><strong style="color: #28a745;">ARTAN:</strong> Fonksiyon yukarƒ± doƒüru gidiyor</li>
                                <li><strong style="color: #dc3545;">AZALAN:</strong> Fonksiyon a≈üaƒüƒ± doƒüru gidiyor</li>
                                <li><strong style="color: #17a2b8;">SABƒ∞T:</strong> Fonksiyon d√ºz gidiyor</li>
                            </ul>
                        </li>
                        <li style="margin-bottom: 0;">
                            <span style="color: #28a745; font-weight: bold;">4Ô∏è‚É£</span> 
                            <strong>"Kontrol Et"</strong> butonuna tƒ±klayarak cevaplarƒ±nƒ±zƒ± kontrol ediniz
                        </li>
                    </ul>
                `;
            } else {
                taskContent.innerHTML = `
                    <div style="margin-bottom: 12px;">
                        <strong style="color: #007bff;">üéØ Durum Se√ßme Modu</strong>
                    </div>
                    <ul style="margin: 0; padding-left: 20px; list-style-type: none;">
                        <li style="margin-bottom: 8px;">
                            <span style="color: #28a745; font-weight: bold;">1Ô∏è‚É£</span> 
                            Yukarƒ±daki <strong>mor fonksiyon grafiƒüini</strong> dikkatli bir ≈üekilde inceleyiniz
                        </li>
                        <li style="margin-bottom: 8px;">
                            <span style="color: #28a745; font-weight: bold;">2Ô∏è‚É£</span> 
                            Tabloda <strong>turuncu renkli aralƒ±klar</strong> verilmi≈ütir
                        </li>
                        <li style="margin-bottom: 8px;">
                            <span style="color: #28a745; font-weight: bold;">3Ô∏è‚É£</span> 
                            Her aralƒ±k i√ßin <strong>a√ßƒ±lƒ±r men√ºden</strong> doƒüru durumu se√ßiniz:
                            <ul style="margin-top: 4px; margin-left: 15px; list-style-type: disc;">
                                <li><strong style="color: #28a745;">ARTAN:</strong> Soldan saƒüa fonksiyon deƒüeri artƒ±yor</li>
                                <li><strong style="color: #dc3545;">AZALAN:</strong> Soldan saƒüa fonksiyon deƒüeri azalƒ±yor</li>
                                <li><strong style="color: #17a2b8;">SABƒ∞T:</strong> Fonksiyon deƒüeri deƒüi≈ümiyor</li>
                            </ul>
                        </li>
                        <li style="margin-bottom: 0;">
                            <span style="color: #28a745; font-weight: bold;">4Ô∏è‚É£</span> 
                            <strong>"Kontrol Et"</strong> butonuna tƒ±klayarak cevaplarƒ±nƒ±zƒ± kontrol ediniz
                        </li>
                    </ul>
                `;
            }
        }

        // Analiz √∂zetini g√ºncelle
        function updateAnalysisSummary(visibleData) {
            const analysisSummary = document.getElementById('analysisSummary');
            
            const increasingCount = visibleData.filter(d => d.status === 'increasing').length;
            const decreasingCount = visibleData.filter(d => d.status === 'decreasing').length;
            const constantCount = visibleData.filter(d => d.status === 'constant').length;
            
            const totalVisible = visibleData.length;
            const totalIntervals = monotonicityData.length;
            
            let summary = `<strong>üìä Fonksiyon #${functionCounter} Analizi:</strong> `;
            
            if (totalVisible < totalIntervals) {
                summary += `(${totalVisible}/${totalIntervals} aralƒ±k) `;
            } else {
                summary += `(Tamamlandƒ±) `;
            }
            
            summary += `<br>`;
            
            if (increasingCount > 0) {
                summary += `‚ÜóÔ∏è ${increasingCount} artan `;
            }
            
            if (decreasingCount > 0) {
                summary += `‚ÜòÔ∏è ${decreasingCount} azalan `;
            }
            
            if (constantCount > 0) {
                summary += `‚û°Ô∏è ${constantCount} sabit `;
            }
            
            summary += `aralƒ±k`;
            
            analysisSummary.innerHTML = summary;
            
            // En geni≈ü aralƒ±k analizi (normal modda tamamlandƒ±ƒüƒ±nda veya SÔøΩra sende modunda doƒüru cevap verildikten sonra)
            if ((!isInteractiveMode && totalVisible === totalIntervals) || (isInteractiveMode && isAnswerCorrect)) {
                calculateIntervalSets(visibleData);
            }
        }
        
        // Aralƒ±k k√ºmelerini hesapla
        function calculateIntervalSets(data) {
            const intervalAnalysis = document.getElementById('intervalAnalysis');
            const longestIncreasing = document.getElementById('longestIncreasing');
            const longestDecreasing = document.getElementById('longestDecreasing');
            const longestConstant = document.getElementById('longestConstant');
            
            // Her tip i√ßin aralƒ±klarƒ± topla ve birle≈ütir
            const increasingIntervals = mergeConsecutiveIntervals(data.filter(d => d.status === 'increasing'));
            const decreasingIntervals = mergeConsecutiveIntervals(data.filter(d => d.status === 'decreasing'));
            const constantIntervals = mergeConsecutiveIntervals(data.filter(d => d.status === 'constant'));
            
            // √ñnce t√ºm divleri gizle
            longestIncreasing.style.display = 'none';
            longestDecreasing.style.display = 'none';
            longestConstant.style.display = 'none';
            
            let hasAnyInterval = false;
            
            // Sonu√ßlarƒ± k√ºme birle≈üimi olarak g√∂ster (sadece bulunanlar i√ßin)
            if (increasingIntervals.length > 0) {
                const unionText = increasingIntervals.join(' ‚à™ ');
                longestIncreasing.innerHTML = `‚ÜóÔ∏è <strong>Artan aralƒ±klar:</strong> ${unionText}`;
                longestIncreasing.style.color = '#28a745';
                longestIncreasing.style.display = 'block';
                hasAnyInterval = true;
            }
            
            if (decreasingIntervals.length > 0) {
                const unionText = decreasingIntervals.join(' ‚à™ ');
                longestDecreasing.innerHTML = `‚ÜòÔ∏è <strong>Azalan aralƒ±klar:</strong> ${unionText}`;
                longestDecreasing.style.color = '#dc3545';
                longestDecreasing.style.display = 'block';
                hasAnyInterval = true;
            }
            
            if (constantIntervals.length > 0) {
                const unionText = constantIntervals.join(' ‚à™ ');
                longestConstant.innerHTML = `‚û°Ô∏è <strong>Sabit aralƒ±klar:</strong> ${unionText}`;
                longestConstant.style.color = '#17a2b8';
                longestConstant.style.display = 'block';
                hasAnyInterval = true;
            }
            
            // En az bir aralƒ±k varsa analiz b√∂l√ºm√ºn√º g√∂ster
            if (hasAnyInterval) {
                intervalAnalysis.style.display = 'block';
            } else {
                intervalAnalysis.style.display = 'none';
            }
        }
        
        // Ardƒ±≈üƒ±k aralƒ±klarƒ± birle≈ütir
        function mergeConsecutiveIntervals(intervals) {
            if (intervals.length === 0) return [];
            
            // Aralƒ±klarƒ± ba≈ülangƒ±√ß X deƒüerine g√∂re sƒ±rala
            intervals.sort((a, b) => a.startX - b.startX);
            
            const merged = [];
            let currentStart = intervals[0].startX;
            let currentEnd = intervals[0].endX;
            
            for (let i = 1; i < intervals.length; i++) {
                const interval = intervals[i];
                
                // Eƒüer bu aralƒ±k bir √∂ncekinin bittiƒüi yerden ba≈ülƒ±yorsa birle≈ütir
                if (interval.startX === currentEnd) {
                    currentEnd = interval.endX;
                } else {
                    // Yeni birle≈ütirilmi≈ü aralƒ±ƒüƒ± ekle
                    merged.push(`[${currentStart}, ${currentEnd}]`);
                    currentStart = interval.startX;
                    currentEnd = interval.endX;
                }
            }
            
            // Son aralƒ±ƒüƒ± ekle
            merged.push(`[${currentStart}, ${currentEnd}]`);
            
            return merged;
        }
    </script>
</body>
</html>
