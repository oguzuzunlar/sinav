<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Fonksiyonlarda Artan ve Azalanlık Etkinliği</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
            color: #333;
            line-height: 1.4;
            min-height: 100vh;
            padding: 10px;
            overflow-x: hidden;
        }

        .container {
            width: 100%;
            max-width: 800px;
            background-color: rgba(255, 255, 255, 0.98);
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            margin: 0 auto;
        }

        /* Desktop layout - iki sütunlu */
        @media (min-width: 769px) {
            .container {
                max-width: 100%;
                width: 100%;
            }
            
            .content {
                display: flex;
                gap: 20px;
                align-items: flex-start;
            }
            
            .graph-container {
                flex: 1;
                min-width: 0;
            }
            
            .monotonicity-table {
                flex: 1;
                min-width: 0;
            }
        }

        header {
            background: linear-gradient(to right, #1a2a6c, #b21f1f);
            color: white;
            padding: 15px;
            text-align: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .logo {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 5px;
        }

        h1 {
            font-size: 1.2rem;
            margin: 0;
            line-height: 1.3;
        }

        .progress-info {
            font-size: 0.9rem;
            opacity: 0.9;
            margin-top: 5px;
        }

        .content {
            padding: 15px;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 12px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }

        .btn {
            padding: 8px 12px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            touch-action: manipulation;
        }

        .btn:active {
            transform: scale(0.98);
        }

        .btn-primary {
            background: linear-gradient(135deg, #1a2a6c, #2d4aa7);
            color: white;
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(135deg, #ffc107, #ffb300);
            color: #333;
        }

        .btn-success:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .graph-container {
            background-color: #f8f9fa;
            padding: 5px;
            border-radius: 4px;
            text-align: center;
            margin-bottom: 5px;
            border: 1px solid #dee2e6;
        }

        .graph-header {
            margin-bottom: 15px;
        }

        .graph-header h3 {
            color: #1a2a6c;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            text-align: center;
            line-height: 1.3;
        }

        .canvas-wrapper {
            position: relative;
            width: 100%;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            margin: 0 auto;
            aspect-ratio: 1;
            border: 2px solid #dee2e6;
            overflow: hidden;
        }

        /* Desktop'ta grafik alanını optimize et */
        @media (min-width: 769px) {
            .canvas-wrapper {
                aspect-ratio: 1.2;
                max-height: 70vh;
            }
        }

        #functionChart {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }

        .monotonicity-table {
            background-color: #fff8e1;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #ff9800;
            position: relative;
            overflow: hidden;
        }

        .monotonicity-table h4 {
            color: #e65100;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1rem;
        }

        .table-container {
            position: relative;
            background: #fff;
            border-radius: 8px;
            border: 2px solid #ffcc02;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            overflow-x: auto;
        }

        .monotonicity-table table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
            min-width: 300px;
        }

        .monotonicity-table th,
        .monotonicity-table td {
            padding: 8px 4px;
            text-align: center;
            border: 1px solid #e0e0e0;
            position: relative;
            transition: all 0.3s ease;
            min-width: 60px;
        }

        .monotonicity-table .interval-row {
            background: linear-gradient(135deg, #ff9800, #ffb74d);
            color: white;
            font-weight: bold;
            font-size: 11px;
        }

        .monotonicity-table .status-row {
            background: #fafafa;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-size: 10px;
        }

        .monotonicity-table .increasing {
            background: linear-gradient(135deg, #e8f5e8, #c8e6c9);
            color: #2e7d32;
        }

        .monotonicity-table .decreasing {
            background: linear-gradient(135deg, #ffebee, #ffcdd2);
            color: #c62828;
        }

        .monotonicity-table .constant {
            background: linear-gradient(135deg, #e3f2fd, #bbdefb);
            color: #1565c0;
        }

        .interactive-cell {
            background: #f8f9fa !important;
            padding: 5px 2px !important;
        }

        .interactive-cell input,
        .interactive-cell select {
            width: 100%;
            border: 1px solid #ccc;
            border-radius: 3px;
            padding: 2px;
            font-size: 10px;
            text-align: center;
        }

        .animated-row {
            animation: slideInLeft 0.5s ease-out;
            border-left: 4px solid #ff9800;
        }

        @keyframes slideInLeft {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .progress-indicator {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: linear-gradient(90deg, rgba(255, 152, 0, 0.1), rgba(255, 152, 0, 0.3));
            transition: width 0.3s ease;
            pointer-events: none;
        }

        .analysis-summary {
            margin-top: 15px;
            padding: 12px;
            background: rgba(255, 152, 0, 0.1);
            border-radius: 6px;
            border: 1px solid #ffcc02;
            font-size: 12px;
            line-height: 1.4;
            display: none;
        }

        .trend-icon {
            display: inline-block;
            margin-right: 5px;
            font-size: 14px;
        }

        .trend-up::before {
            content: "↗️";
        }

        .trend-down::before {
            content: "↘️";
        }

        .trend-flat::before {
            content: "➡️";
        }

        /* Mobil optimizasyonları */
        @media (max-width: 768px) {
            body {
                padding: 5px;
            }
            
            .container {
                border-radius: 5px;
                max-width: 800px;
            }
            
            .content {
                display: block;
            }
            
            header {
                padding: 10px;
            }
            
            h1 {
                font-size: 1rem;
            }
            
            .content {
                padding: 10px;
            }
            
            .graph-container {
                padding: 10px;
                margin-bottom: 15px;
            }
            
            .monotonicity-table {
                padding: 10px;
            }
            
            .monotonicity-table table {
                font-size: 10px;
            }
            
            .monotonicity-table th,
            .monotonicity-table td {
                padding: 6px 2px;
                min-width: 50px;
            }
        }

        /* Landscape orientation */
        @media (orientation: landscape) and (max-height: 600px) {
            .canvas-wrapper {
                aspect-ratio: 4/3;
            }
        }

        /* Welcome Section Styles */
        .welcome-container {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
        }

        .welcome-content {
            max-width: 900px;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.3);
            text-align: center;
            animation: welcomeFadeIn 1s ease-out;
        }

        @keyframes welcomeFadeIn {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .welcome-header {
            margin-bottom: 30px;
        }

        .welcome-logo {
            margin-bottom: 15px;
        }

        .welcome-title {
            font-size: 2.5rem;
            color: #1a2a6c;
            margin-bottom: 8px;
            font-weight: 700;
        }

        .welcome-subtitle {
            font-size: 1.2rem;
            color: #b21f1f;
            font-weight: 500;
            margin-bottom: 20px;
        }

        .welcome-description {
            text-align: left;
            margin-bottom: 30px;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .feature-item {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .feature-item:hover {
            border-color: #1a2a6c;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(26, 42, 108, 0.1);
        }

        .feature-icon {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .feature-item h3 {
            color: #1a2a6c;
            margin-bottom: 8px;
            font-size: 1.1rem;
        }

        .feature-item p {
            color: #6c757d;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .learning-objectives,
        .how-it-works {
            background: #fff;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .learning-objectives h3,
        .how-it-works h3 {
            color: #1a2a6c;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .learning-objectives ul {
            list-style: none;
            padding-left: 0;
        }

        .learning-objectives li {
            padding: 8px 0;
            border-bottom: 1px solid #f1f3f4;
            position: relative;
            padding-left: 25px;
        }

        .learning-objectives li:before {
            content: "✓";
            position: absolute;
            left: 0;
            color: #28a745;
            font-weight: bold;
        }

        .learning-objectives li:last-child {
            border-bottom: none;
        }

        .steps {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .step {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px;
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border-radius: 10px;
        }

        .step-number {
            background: linear-gradient(135deg, #1a2a6c, #2c5aa0);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.1rem;
            flex-shrink: 0;
        }

        .step-content {
            flex: 1;
        }

        .step-content strong {
            color: #1a2a6c;
        }

        .welcome-actions {
            text-align: center;
        }

        .start-btn {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .start-btn:hover {
            background: linear-gradient(135deg, #218838, #1cc88a);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(40, 167, 69, 0.3);
        }

        .welcome-note {
            color: #6c757d;
            font-size: 0.9rem;
            max-width: 400px;
            margin: 0 auto;
            line-height: 1.4;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .welcome-content {
                padding: 20px;
                margin: 10px;
            }

            .welcome-title {
                font-size: 1.8rem;
            }

            .welcome-subtitle {
                font-size: 1rem;
            }

            .feature-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }

            .steps {
                gap: 10px;
            }

            .step {
                padding: 12px;
            }

            .step-number {
                width: 35px;
                height: 35px;
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <!-- Giriş Bölümü -->
    <div id="welcomeSection" class="welcome-container">
        <div class="welcome-content">
            <div class="welcome-header">
                <div class="welcome-logo">
                    <svg xmlns="http://www.w3.org/2000/svg" width="60" height="60" viewBox="0 0 24 24" fill="none" stroke="#FFD700" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M3 3v18h18"></path>
                        <path d="M19 9l-5 5-4-4-3 3"></path>
                    </svg>
                </div>
                <h1 class="welcome-title">Fonksiyonlarda Artan ve Azalanlık</h1>
                <p class="welcome-subtitle">İnteraktif Matematik Etkinliği</p>
            </div>
            
            <div class="welcome-description">
                <div class="feature-grid">
                    <div class="feature-item">
                        <div class="feature-icon">📊</div>
                        <h3>Simulasyon Modu</h3>
                        <p>5 farklı fonksiyonun monotonluk analizini animasyonlu olarak inceleyin</p>
                    </div>
                    <div class="feature-item">
                        <div class="feature-icon">🎯</div>
                        <h3>Sıra Sende Modu</h3>
                        <p>10 egzersizde fonksiyonların artan/azalan aralıklarını kendiniz bulun</p>
                    </div>
                    <div class="feature-item">
                        <div class="feature-icon">📐</div>
                        <h3>İki Farklı Zorluk</h3>
                        <p>Durum seçme ve aralık yazma modlarında yeteneklerinizi test edin</p>
                    </div>
                </div>
                
                <div class="learning-objectives">
                    <h3>🎓 Öğrenme Hedefleri:</h3>
                    <ul>
                        <li>Fonksiyonların grafik üzerindeki artan ve azalan davranışlarını anlama</li>
                        <li>Monotonluk aralıklarını doğru şekilde belirleme</li>
                        <li>Grafik okuma ve analiz becerilerini geliştirme</li>
                        <li>Matematiksel notation kullanımını pekiştirme</li>
                    </ul>
                </div>
                
                <div class="how-it-works">
                    <h3>🚀 Nasıl Çalışır:</h3>
                    <div class="steps">
                        <div class="step">
                            <span class="step-number">1</span>
                            <div class="step-content">
                                <strong>Simulasyon:</strong> Önce 5 fonksiyonun analizini izleyin ve öğrenin
                            </div>
                        </div>
                        <div class="step">
                            <span class="step-number">2</span>
                            <div class="step-content">
                                <strong>Uygulama:</strong> "Sıra Sende" butonuna tıklayarak egzersizlere başlayın
                            </div>
                        </div>
                        <div class="step">
                            <span class="step-number">3</span>
                            <div class="step-content">
                                <strong>Değerlendirme:</strong> Her egzersizde cevaplarınızı kontrol edin ve öğrenin
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="welcome-actions">
                <button id="startSimulationBtn" class="start-btn primary">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polygon points="5,3 19,12 5,21"></polygon>
                    </svg>
                    Simulasyonu Başlat
                </button>
                <p class="welcome-note">
                    💡 <strong>İpucu:</strong> İlk kez kullanıyorsanız simulasyon modunda başlamanızı öneririz!
                </p>
            </div>
        </div>
    </div>

    <div class="container" id="mainApplication" style="display: none;">
        <header>
            <div class="logo">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#FFD700" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 12h18m-9-9v18"></path>
                    <circle cx="12" cy="12" r="3"></circle>
                </svg>
                <h1>Fonksiyonlarda Artan ve Azalanlık Etkinliği</h1>
            </div>
            <div style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap;">
                <div class="progress-info" id="progressInfo">
                    Fonksiyon: 0/10
                </div>
            </div>
        </header>
        
        <div class="content">
            
            <div class="graph-container">
                <div class="graph-header" style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 5px;">

                    <div class="controls" style="margin: 0; flex-shrink: 0;">
                        <button class="btn btn-primary" id="generateBtn">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M9 18l6-6-6-6"></path>
                            </svg>
                            Sonraki Fonksiyon
                        </button>

                        <button class="btn btn-success" id="nextBtn" style="display: none;" disabled>
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M9 18l6-6-6-6"></path>
                            </svg>
                            Sonraki Fonksiyon
                        </button>
                    </div>
                </div>
                <div class="canvas-wrapper">
                    <canvas id="functionChart"></canvas>
                </div>
            </div>

            <div class="monotonicity-table">
                <h4>
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#e65100" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M3 12h18"></path>
                        <path d="M8 8l4-4 4 4"></path>
                        <path d="M8 16l4 4 4-4"></path>
                    </svg>
                    Dinamik Artan/Azalan İncelemesi
                </h4>
                <div class="table-container">
                    <div class="progress-indicator" id="tableProgressIndicator"></div>
                    <table id="monotonicityTable">
                        <tbody id="monotonicityTableBody">
                            <tr>
                                <td colspan="100%" style="text-align: center; padding: 20px; color: #666;">
                                    Grafik üretildikten sonra inceleme tablosu burada görüntülenecektir.
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <div class="interval-analysis" id="intervalAnalysis" style="display: none; margin-top: 10px; padding: 12px; background: #f8f9fa; border-radius: 6px; border-left: 4px solid #007bff;">
                  
                    <div style="margin-top: 6px; font-size: 13px;">
                        <div id="longestIncreasing" style="display: none;">↗️ <strong>En geniş artan aralık:</strong> -</div>
                        <div id="longestDecreasing" style="display: none;">↘️ <strong>En geniş azalan aralık:</strong> -</div>
                        <div id="longestConstant" style="display: none;">➡️ <strong>En geniş sabit aralık:</strong> -</div>
                    </div>
                </div>
                <div class="analysis-summary" id="analysisSummary">
                    <strong>📊 İnceleme Özeti:</strong> Henüz inceleme başlamadı. Grafik animasyonu başladığında dinamik olarak güncellenecektir.
                </div>
                
                <!-- Göreviniz bölümü - sadece S�ra sende modunda görünür -->
                <div class="task-instructions" id="taskInstructions" style="display: none; margin-top: 15px; padding: 15px; background: linear-gradient(135deg, #f8f9fa, #e9ecef); border-radius: 8px; border-left: 4px solid #007bff;">
                    <div style="display: flex; align-items: center; margin-bottom: 10px;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#007bff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                            <circle cx="12" cy="12" r="10"></circle>
                            <path d="M9,12l2,2 4,-4"></path>
                        </svg>
                        <strong style="color: #007bff; font-size: 16px;">📋 Göreviniz</strong>
                    </div>
                    <div id="taskContent" style="font-size: 14px; line-height: 1.5; color: #495057;">
                        <!-- Görev içeriği buraya gelecek -->
                    </div>
                </div>
                
                <!-- Sıra sende mod kontrol butonları -->
                <div class="interactive-controls" id="interactiveControls" style="display: none; margin-top: 15px; text-align: center;">
                    <button class="btn btn-warning" id="checkBtn" style="margin-right: 10px;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M9 12l2 2 4-4"></path>
                            <circle cx="12" cy="12" r="10"></circle>
                        </svg>
                        Kontrol Et
                    </button>
                    <div class="feedback-message" id="feedbackMessage" style="margin-top: 10px; padding: 10px; border-radius: 6px; display: none;"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global değişkenler
        let currentPoints = [];
        let currentGraphType = '';
        let xIntercepts = [];
        let canvas, ctx;
        let animationId = null;
        let animationProgress = 0;
        let isAnimating = false;
        let animationSpeed = 0.01; // Daima yavaş animasyon
        let monotonicityData = [];
        let criticalPoints = [];
        let currentAnalysisIndex = 0;
        let functionCounter = 0;
        let maxFunctions = 5;
        let isInteractiveMode = false;
        let interactiveFunctionCounter = 0;
        let maxInteractiveFunctions = 10;
        let currentInteractiveData = null;
        let isAnswerCorrect = false;
        let nextButtonEnabled = false;
        
        // Beğenilen fonksiyonlar için yeni değişkenler
        let savedFunctions = [];
        let currentFunctionData = null;
        
        // JSON dosyasından yüklenen fonksiyonlar için değişkenler
        let jsonFunctions = [];
        let selectedJsonFunctions = [];
        let currentJsonIndex = 0;
        
        // Egzersiz bölümü için JSON fonksiyonları
        let interactiveJsonFunctions = [];
        let currentInteractiveJsonIndex = 0;
        
        // Sayfa yüklendiğinde başlat
        document.addEventListener('DOMContentLoaded', function() {
            // Giriş bölümü buton event listener'ı
            const startSimulationBtn = document.getElementById('startSimulationBtn');
            startSimulationBtn.addEventListener('click', function() {
                // Giriş bölümünü gizle ve ana uygulamayı göster
                document.getElementById('welcomeSection').style.display = 'none';
                document.getElementById('mainApplication').style.display = 'block';
                
                // Canvas ve diğer bileşenleri başlat
                initializeApplication();
            });
        });
        
        // Ana uygulamayı başlat
        function initializeApplication() {
            canvas = document.getElementById('functionChart');
            ctx = canvas.getContext('2d');
            setupCanvas();
            setupEventListeners();
            updateProgressInfo();
            
            // JSON dosyasını yükle ve ilk fonksiyonu göster
            loadJsonFunctions();
        }
        
        // JSON dosyasından fonksiyonları yükle
        async function loadJsonFunctions() {
            try {
                const response = await fetch('./fonk2.json');
                if (!response.ok) {
                    throw new Error('JSON dosyası yüklenemedi');
                }
                
                const data = await response.json();
                jsonFunctions = data.functions || [];
                
                if (jsonFunctions.length === 0) {
                    console.error('JSON dosyasında fonksiyon bulunamadı');
                    // Fallback olarak rastgele fonksiyon üret
                    generateRandomFunction();
                    return;
                }
                
                // 5 rastgele fonksiyon seç (simulasyon için)
                selectRandomJsonFunctions();
                
                // 10 rastgele fonksiyon seç (egzersiz için)
                selectRandomInteractiveJsonFunctions();
                
                // İlk fonksiyonu yükle
                loadJsonFunction(0);
                
            } catch (error) {
                console.error('JSON dosyası yüklenirken hata:', error);
                // Fallback olarak rastgele fonksiyon üret
                generateRandomFunction();
            }
        }
        
        // 5 rastgele fonksiyon seç (simulasyon için)
        function selectRandomJsonFunctions() {
            selectedJsonFunctions = [];
            const availableIndices = [...Array(jsonFunctions.length).keys()];
            
            // 5 rastgele indeks seç
            for (let i = 0; i < 5; i++) {
                if (availableIndices.length === 0) break;
                
                const randomIndex = Math.floor(Math.random() * availableIndices.length);
                const selectedIndex = availableIndices.splice(randomIndex, 1)[0];
                selectedJsonFunctions.push(jsonFunctions[selectedIndex]);
            }
            
            currentJsonIndex = 0;
        }
        
        // 10 rastgele fonksiyon seç (egzersiz için)
        function selectRandomInteractiveJsonFunctions() {
            interactiveJsonFunctions = [];
            const availableIndices = [...Array(jsonFunctions.length).keys()];
            
            // 10 rastgele indeks seç
            for (let i = 0; i < 10; i++) {
                if (availableIndices.length === 0) break;
                
                const randomIndex = Math.floor(Math.random() * availableIndices.length);
                const selectedIndex = availableIndices.splice(randomIndex, 1)[0];
                interactiveJsonFunctions.push(jsonFunctions[selectedIndex]);
            }
            
            currentInteractiveJsonIndex = 0;
        }
        
        // JSON'dan seçilen fonksiyonu yükle
        function loadJsonFunction(index) {
            if (index >= selectedJsonFunctions.length) {
                // Tüm simulasyon fonksiyonları tamamlandı, interaktif moda geç
                isInteractiveMode = true;
                interactiveFunctionCounter = 0;
                updateProgressInfo();
                generateInteractiveFunction();
                return;
            }
            
            stopAnimation();
            
            const func = selectedJsonFunctions[index];
            currentPoints = func.points || [];
            xIntercepts = func.xIntercepts || [];
            currentGraphType = func.graphType || 'curved';
            
            functionCounter = index + 1;
            updateProgressInfo();
            
            // Artan/azalan analizi için veri hazırla
            prepareMonotonicityAnalysis();
            
            updateGraphTitle();
            resetMonotonicityTable();
            
            startDrawAnimation();
        }
        
        // Egzersiz fonksiyonları bittiğinde yeniden karıştır
        function reshuffleInteractiveFunctions() {
            if (jsonFunctions.length > 0) {
                selectRandomInteractiveJsonFunctions();
                console.log('Egzersiz fonksiyonları yeniden karıştırıldı');
            }
        }
        
        // Event listener'ları ayarla
        function setupEventListeners() {
            document.getElementById('generateBtn').addEventListener('click', generateRandomFunction);
            document.getElementById('checkBtn').addEventListener('click', checkAnswer);
            document.getElementById('nextBtn').addEventListener('click', generateRandomFunction);
            window.addEventListener('resize', setupCanvas);
            
            // Touch event optimizasyonları - sadece canvas için
            canvas.addEventListener('touchstart', function(e) {
                e.preventDefault();
            }, { passive: false });
            
            canvas.addEventListener('touchmove', function(e) {
                e.preventDefault();
            }, { passive: false });
        }
        
        // İlerleme bilgisini güncelle
        function updateProgressInfo() {
            const progressInfo = document.getElementById('progressInfo');
            const generateBtn = document.getElementById('generateBtn');
            const interactiveControls = document.getElementById('interactiveControls');
            const taskInstructions = document.getElementById('taskInstructions');
            const nextBtn = document.getElementById('nextBtn');
            
            if (!isInteractiveMode) {
                progressInfo.textContent = `Fonksiyon: ${functionCounter}/5`;
                interactiveControls.style.display = 'none';
                taskInstructions.style.display = 'none';
                
                if (functionCounter >= maxFunctions) {
                    generateBtn.disabled = false;
                    generateBtn.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M9 12l2 2 4-4"></path>
                            <circle cx="12" cy="12" r="10"></circle>
                        </svg>
                        Sıra Sende
                    `;
                    generateBtn.style.background = 'linear-gradient(135deg, #28a745, #20c997)';
                } else {
                    generateBtn.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M9 18l6-6-6-6"></path>
                        </svg>
                        Sonraki Fonksiyon
                    `;
                }
            } else {
                progressInfo.textContent = `Sıra Sende: ${interactiveFunctionCounter}/${maxInteractiveFunctions}`;
                
                if (interactiveFunctionCounter >= maxInteractiveFunctions) {
                    generateBtn.style.display = 'none';
                    interactiveControls.style.display = 'none';
                    taskInstructions.style.display = 'none';
                    nextBtn.style.display = 'none';
                    
                    // Tamamlandı mesajı göster
                    const controls = document.querySelector('.controls');
                    controls.innerHTML = `
                        <div style="text-align: center; padding: 20px; background: #d4edda; border-radius: 8px; color: #155724;">
                            <h3>🎉 Tebrikler!</h3>
                            <p>Tüm egzersizleri başarıyla tamamladınız!</p>
                        </div>
                    `;
                } else {
                    generateBtn.style.display = 'none';
                    interactiveControls.style.display = 'block';
                    taskInstructions.style.display = 'block';
                    nextBtn.style.display = 'flex';
                    nextBtn.disabled = !nextButtonEnabled;
                }
            }
        }
        
        // Canvas boyutlarını ayarla
        function setupCanvas() {
            const canvasWrapper = document.querySelector('.canvas-wrapper');
            const width = canvasWrapper.clientWidth;
            const height = canvasWrapper.clientHeight;
            
            // Retina display desteği
            const ratio = window.devicePixelRatio || 1;
            canvas.width = width * ratio;
            canvas.height = height * ratio;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            ctx.scale(ratio, ratio);
            
            if (currentPoints.length > 0) {
                if (isAnimating) {
                    drawCoordinateSystem();
                } else {
                    drawGraph();
                }
            } else {
                drawEmptyGraph();
            }
        }
        
        // Rastgele tam sayı üret
        function randomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        
        // X eksenini kesen noktalar üret
        function generateXIntercepts() {
            const numIntercepts = randomInt(1, 3);
            const intercepts = [];
            const usedX = new Set();
            
            while (intercepts.length < numIntercepts) {
                const x = randomInt(-10, 10);
                if (!usedX.has(x)) {
                    usedX.add(x);
                    intercepts.push(x);
                }
            }
            
            return intercepts.sort((a, b) => a - b);
        }
        
        // X kesim noktalarından geçen fonksiyon noktaları üret
        function generatePointsFromIntercepts(intercepts) {
            const points = [];
            
            intercepts.forEach(x => {
                points.push({x: x, y: 0});
            });
            
            const additionalPoints = 5 - intercepts.length;
            const usedX = new Set(intercepts);
            
            // Önce tüm x koordinatlarını belirle
            const allXCoords = [...intercepts];
            for (let i = 0; i < additionalPoints; i++) {
                let x;
                let attempts = 0;
                do {
                    x = randomInt(-10, 10);
                    attempts++;
                } while (usedX.has(x) && attempts < 50);
                
                if (usedX.has(x)) {
                    for (let testX = -10; testX <= 10; testX++) {
                        if (!usedX.has(testX)) {
                            x = testX;
                            break;
                        }
                    }
                }
                usedX.add(x);
                allXCoords.push(x);
            }
            
            // X koordinatlarını sırala
            allXCoords.sort((a, b) => a - b);
            
            // Y değerlerini stratejik olarak ata
            for (let i = 0; i < allXCoords.length; i++) {
                const x = allXCoords[i];
                
                // Eğer x-intercept ise y=0
                if (intercepts.includes(x)) {
                    continue; // Zaten eklendi
                }
                
                let y;
                
                if (points.length === 0) {
                    // İlk nokta rastgele
                    y = randomInt(-8, 8);
                } else if (points.length === 1) {
                    // İkinci nokta da nispeten serbest
                    y = randomInt(-8, 8);
                } else {
                    // Üçüncü ve sonraki noktalar için ardışık segment kontrolü
                    const sortedPoints = [...points].sort((a, b) => a.x - b.x);
                    
                    // Son iki noktayı bul
                    const lastPoint = sortedPoints[sortedPoints.length - 1];
                    const secondLastPoint = sortedPoints[sortedPoints.length - 2];
                    
                    // Önceki segmentin eğimini hesapla
                    const prevSlope = (lastPoint.y - secondLastPoint.y) / (lastPoint.x - secondLastPoint.x);
                    
                    // Yeni segmentin farklı davranış sergilemesi için y değerini belirle
                    if (prevSlope > 0.1) {  // Eşik değerini düşürdük
                        // Önceki segment ARTAN ise -> AZALAN veya SABİT yap
                        if (Math.random() < 0.7) {
                            // %70 ihtimalle azalan
                            y = lastPoint.y - randomInt(3, 8);
                        } else {
                            // %30 ihtimalle sabit
                            y = lastPoint.y + randomInt(-1, 1);
                        }
                    } else if (prevSlope < -0.1) {  // Eşik değerini düşürdük
                        // Önceki segment AZALAN ise -> ARTAN veya SABİT yap
                        if (Math.random() < 0.7) {
                            // %70 ihtimalle artan
                            y = lastPoint.y + randomInt(3, 8);
                        } else {
                            // %30 ihtimalle sabit
                            y = lastPoint.y + randomInt(-1, 1);
                        }
                    } else {
                        // Önceki segment SABİT ise -> ARTAN veya AZALAN yap
                        if (Math.random() < 0.5) {
                            // %50 artan
                            y = lastPoint.y + randomInt(3, 8);
                        } else {
                            // %50 azalan
                            y = lastPoint.y - randomInt(3, 8);
                        }
                    }
                    
                    // Y sınırlarını kontrol et
                    y = Math.max(-10, Math.min(10, y));
                }
                
                // Y=0 durumunu önle (x-intercept ile karışmasın)
                if (y === 0) y = Math.random() < 0.5 ? 1 : -1;
                
                points.push({x, y});
            }
            
            return points.sort((a, b) => a.x - b.x);
        }
        
        // Rastgele fonksiyon üret
        function generateRandomFunction() {
            if (!isInteractiveMode && functionCounter >= maxFunctions) {
                // İnteraktif moda geç
                isInteractiveMode = true;
                interactiveFunctionCounter = 0;
                updateProgressInfo();
                generateInteractiveFunction();
                return;
            }
            
            if (isInteractiveMode && interactiveFunctionCounter >= maxInteractiveFunctions) return;
            
            if (isInteractiveMode) {
                generateInteractiveFunction();
                return;
            }
            
            // Eğer JSON fonksiyonları mevcutsa onları kullan
            if (selectedJsonFunctions.length > 0 && currentJsonIndex < selectedJsonFunctions.length) {
                loadJsonFunction(currentJsonIndex);
                currentJsonIndex++;
                return;
            }
            
            // JSON fonksiyonları bittiyse veya yoksa rastgele üret
            stopAnimation();
            
            functionCounter++;
            updateProgressInfo();
            
            xIntercepts = generateXIntercepts();
            currentPoints = generatePointsFromIntercepts(xIntercepts);
            
            // Rastgele çizgi tipi seç - %40 doğrusal, %60 eğrisel
            currentGraphType = Math.random() < 0.4 ? 'linear' : 'curved';
            
            // Artan/azalan analizi için veri hazırla
            prepareMonotonicityAnalysis();
            
            updateGraphTitle();
            resetMonotonicityTable();
            
            startDrawAnimation();
        }
        
        // Animasyon başlatma
        function startDrawAnimation() {
            animationProgress = 0;
            isAnimating = true;
            currentAnalysisIndex = 0;
            
            drawCoordinateSystem();
            animateDrawing();
        }
        
        // Animasyonu durdurma
        function stopAnimation() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            isAnimating = false;
            animationProgress = 1;
            currentAnalysisIndex = monotonicityData.length;
            
            if (currentPoints.length > 0) {
                drawGraph();
                
                // İnteraktif modda tablo oluşturma
                if (isInteractiveMode) {
                    createInteractiveTable();
                } else {
                    completeMonotonicityTable();
                }
            }
        }
        
        // Çizim animasyonu
        function animateDrawing() {
            if (!isAnimating) return;
            
            animationProgress += animationSpeed;
            
            if (animationProgress >= 1) {
                animationProgress = 1;
                isAnimating = false;
                
                // İnteraktif modda tablo oluşturma
                if (isInteractiveMode) {
                    createInteractiveTable();
                } else {
                    completeMonotonicityTable();
                }
            }
            
            drawCoordinateSystem();
            drawAnimatedContinuousGraph();
            drawAnimatedPoints();
            
            // Normal modda animasyon sırasında tablo güncelle
            if (!isInteractiveMode) {
                updateMonotonicityTableWithAnimation();
            }
            
            if (isAnimating) {
                animationId = requestAnimationFrame(animateDrawing);
            }
        }
        
        // Koordinat sistemini çiz
        function drawCoordinateSystem() {
            const width = canvas.style.width ? parseInt(canvas.style.width) : canvas.width;
            const height = canvas.style.height ? parseInt(canvas.style.height) : canvas.height;
            
            const padding = Math.min(width, height) * 0.1;
            const centerX = width / 2;
            const centerY = height / 2;
            // Scale'i -10 ile +10 sayıları sığacak şekilde ayarla
            const availableWidth = (width - padding * 2) / 2; // Sağ tarafın genişliği
            const availableHeight = (height - padding * 2) / 2; // Üst tarafın yüksekliği
            const scaleX = availableWidth / 10; // X ekseni için 10 birim scale
            const scaleY = availableHeight / 10; // Y ekseni için 10 birim scale
            
            ctx.clearRect(0, 0, width, height);
            
            // Grid çizgileri çiz (ana eksenlerden önce)
            // Mobil optimizasyonu - ekran boyutuna göre grid ayarları
            const isMobile = width < 500; // Mobil tespit
            
            // Mobilde daha belirgin grid için ayarlar
            if (isMobile) {
                ctx.strokeStyle = '#e8e8e8'; // Daha koyu gri
                ctx.lineWidth = 0.8; // Daha kalın çizgi
                ctx.globalAlpha = 0.7; // Daha opak
            } else {
                ctx.strokeStyle = '#e0e0e0'; // Masaüstü için normal
                ctx.lineWidth = 0.5;
                ctx.globalAlpha = 0.6;
            }
            
            // Dikey grid çizgileri
            for (let i = -10; i <= 10; i++) {
                if (i === 0) continue; // Ana Y ekseni atlanacak
                const x = centerX + i * scaleX;
                if (x >= padding && x <= width - padding) {
                    ctx.beginPath();
                    ctx.moveTo(x, padding);
                    ctx.lineTo(x, height - padding);
                    ctx.stroke();
                }
            }
            
            // Yatay grid çizgileri
            for (let i = -10; i <= 10; i++) {
                if (i === 0) continue; // Ana X ekseni atlanacak
                const y = centerY - i * scaleY;
                if (y >= padding && y <= height - padding) {
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(width - padding, y);
                    ctx.stroke();
                }
            }
            
            // Grid çizimi tamamlandıktan sonra alpha'yı sıfırla
            ctx.globalAlpha = 1;
            
            // X ekseni (ana)
            ctx.beginPath();
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.moveTo(padding, centerY);
            ctx.lineTo(width - padding, centerY);
            ctx.stroke();
            
            // Y ekseni (ana)
            ctx.beginPath();
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 2;
            ctx.moveTo(centerX, height - padding);
            ctx.lineTo(centerX, padding);
            ctx.stroke();
            
            // Ok işaretleri
            const arrowSize = Math.min(scaleX, scaleY) * 0.4;
            
            // X ekseni sağ ok
            ctx.beginPath();
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            const xArrowTip = width - padding;
            ctx.moveTo(xArrowTip - arrowSize, centerY - arrowSize/2);
            ctx.lineTo(xArrowTip, centerY);
            ctx.lineTo(xArrowTip - arrowSize, centerY + arrowSize/2);
            ctx.stroke();
            
            // X ekseni sol ok
            ctx.beginPath();
            const xArrowLeftTip = padding;
            ctx.moveTo(xArrowLeftTip + arrowSize, centerY - arrowSize/2);
            ctx.lineTo(xArrowLeftTip, centerY);
            ctx.lineTo(xArrowLeftTip + arrowSize, centerY + arrowSize/2);
            ctx.stroke();
            
            // Y ekseni yukarı ok
            ctx.beginPath();
            ctx.strokeStyle = '#2c3e50';
            const yArrowTip = padding;
            ctx.moveTo(centerX - arrowSize/2, yArrowTip + arrowSize);
            ctx.lineTo(centerX, yArrowTip);
            ctx.lineTo(centerX + arrowSize/2, yArrowTip + arrowSize);
            ctx.stroke();
            
            // Y ekseni aşağı ok
            ctx.beginPath();
            const yArrowBottomTip = height - padding;
            ctx.moveTo(centerX - arrowSize/2, yArrowBottomTip - arrowSize);
            ctx.lineTo(centerX, yArrowBottomTip);
            ctx.lineTo(centerX + arrowSize/2, yArrowBottomTip - arrowSize);
            ctx.stroke();
            
            // Eksen noktaları
            ctx.fillStyle = '#2c3e50';
            for (let i = -10; i <= 10; i++) {
                if (i === 0) continue;
                const x = centerX + i * scaleX;
                if (x >= padding && x <= width - padding) {
                    ctx.beginPath();
                    ctx.arc(x, centerY, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            for (let i = -10; i <= 10; i++) {
                if (i === 0) continue;
                const y = centerY - i * scaleY;
                if (y >= padding && y <= height - padding) {
                    ctx.beginPath();
                    ctx.arc(centerX, y, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Mobil için daha küçük etiketler
            const fontSize = Math.max(8, Math.min(12, width * 0.025));
            ctx.fillStyle = '#2c3e50';
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = 'center';
            
            // X ekseni etiketleri - 1'den 10'a kadar ardışık
            for (let i = 1; i <= 10; i++) {
                const x = centerX + i * scaleX;
                if (x >= padding && x <= width - padding) {
                    ctx.fillText(i.toString(), x, centerY + fontSize + 3);
                }
            }
            
            // X ekseni negatif etiketler
            for (let i = -10; i <= -1; i++) {
                const x = centerX + i * scaleX;
                if (x >= padding && x <= width - padding) {
                    ctx.fillText(i.toString(), x, centerY + fontSize + 3);
                }
            }
            
            // Y ekseni etiketleri - 1'den 10'a kadar ardışık
            ctx.textAlign = 'right';
            for (let i = 1; i <= 10; i++) {
                const y = centerY - i * scaleY;
                if (y >= padding && y <= height - padding) {
                    ctx.fillText(i.toString(), centerX - 5, y + fontSize/3);
                }
            }
            
            // Y ekseni negatif etiketler
            for (let i = -10; i <= -1; i++) {
                const y = centerY - i * scaleY;
                if (y >= padding && y <= height - padding) {
                    ctx.fillText(i.toString(), centerX - 5, y + fontSize/3);
                }
            }
            
            ctx.fillText('0', centerX - fontSize, centerY + fontSize + 3);
            
            // Eksen isimleri
            ctx.font = `bold ${fontSize + 2}px Arial`;
            ctx.fillStyle = '#1a2a6c';
            ctx.textAlign = 'center';
            ctx.fillText('x', width - padding + fontSize, centerY - 5);
            ctx.fillText('y', centerX + fontSize, padding - 5);
        }
        
        // Koordinat dönüşüm fonksiyonları
        function toCanvasX(x) {
            const width = canvas.style.width ? parseInt(canvas.style.width) : canvas.width;
            const height = canvas.style.height ? parseInt(canvas.style.height) : canvas.height;
            
            const padding = Math.min(width, height) * 0.1;
            
            // Scale'i -10 ile +10 sayıları sığacak şekilde ayarla
            const availableWidth = (width - padding * 2) / 2;
            const scaleX = availableWidth / 10;
            return width / 2 + x * scaleX;
        }
        
        function toCanvasY(y) {
            const width = canvas.style.width ? parseInt(canvas.style.width) : canvas.width;
            const height = canvas.style.height ? parseInt(canvas.style.height) : canvas.height;
            
            const padding = Math.min(width, height) * 0.1;
            
            // Scale'i -10 ile +10 sayıları sığacak şekilde ayarla
            const availableHeight = (height - padding * 2) / 2;
            const scaleY = availableHeight / 10;
            return height / 2 - y * scaleY;
        }
        
        // Segment rengini belirle
        function getSegmentColor(startPoint, endPoint) {
            // Eğer S�ra sende modunda ise tamamen siyah renk kullan
            if (isInteractiveMode) {
                return '#000000'; // Siyah
            }
            
            const deltaY = endPoint.y - startPoint.y;
            const deltaX = endPoint.x - startPoint.x;
            const slope = deltaY / deltaX;
            
            if (slope > 0.01) {  // Eşik değerini düşürdük
                return '#28a745'; // Artan - Yeşil
            } else if (slope < -0.01) {  // Eşik değerini düşürdük
                return '#dc3545'; // Azalan - Kırmızı  
            } else {
                return '#17a2b8'; // Sabit - Mavi
            }
        }

        // Animasyonlu sürekli grafik çizimi
        function drawAnimatedContinuousGraph() {
            if (currentPoints.length === 0) return;
            
            const minX = Math.min(...currentPoints.map(p => p.x));
            const maxX = Math.max(...currentPoints.map(p => p.x));
            const currentMaxX = minX + (maxX - minX) * animationProgress;
            
            ctx.lineWidth = 4;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 2;
            ctx.shadowOffsetX = 1;
            ctx.shadowOffsetY = 1;
            
            if (isInteractiveMode) {
                // İnteraktif modda tek mor çizgi
                ctx.beginPath();
                ctx.moveTo(toCanvasX(currentPoints[0].x), toCanvasY(currentPoints[0].y));
                
                for (let i = 1; i < currentPoints.length; i++) {
                    const prev = currentPoints[i-1];
                    const current = currentPoints[i];
                    
                    if (prev.x > currentMaxX) break;
                    
                    let endPoint = current;
                    if (current.x > currentMaxX) {
                        const t = (currentMaxX - prev.x) / (current.x - prev.x);
                        endPoint = {
                            x: prev.x + t * (current.x - prev.x),
                            y: prev.y + t * (current.y - prev.y)
                        };
                    }
                    
                    if (currentGraphType === 'linear') {
                        ctx.lineTo(toCanvasX(endPoint.x), toCanvasY(endPoint.y));
                    } else {
                        const controlX1 = toCanvasX(prev.x) + (toCanvasX(endPoint.x) - toCanvasX(prev.x)) * 0.3;
                        const controlY1 = toCanvasY(prev.y);
                        const controlX2 = toCanvasX(prev.x) + (toCanvasX(endPoint.x) - toCanvasX(prev.x)) * 0.7;
                        const controlY2 = toCanvasY(endPoint.y);
                        ctx.bezierCurveTo(controlX1, controlY1, controlX2, controlY2, toCanvasX(endPoint.x), toCanvasY(endPoint.y));
                    }
                    
                    if (current.x > currentMaxX) break;
                }
                ctx.strokeStyle = '#9C27B0'; // Mor renk
                ctx.stroke();
            } else {
                // Normal modda renkli segmentler
                for (let i = 1; i < currentPoints.length; i++) {
                    const prev = currentPoints[i-1];
                    const current = currentPoints[i];
                    
                    if (prev.x > currentMaxX) break;
                    
                    let endPoint = current;
                    if (current.x > currentMaxX) {
                        const t = (currentMaxX - prev.x) / (current.x - prev.x);
                        endPoint = {
                            x: prev.x + t * (current.x - prev.x),
                            y: prev.y + t * (current.y - prev.y)
                        };
                    }
                    
                    ctx.strokeStyle = getSegmentColor(prev, endPoint);
                    ctx.beginPath();
                    ctx.moveTo(toCanvasX(prev.x), toCanvasY(prev.y));
                    
                    if (currentGraphType === 'linear') {
                        ctx.lineTo(toCanvasX(endPoint.x), toCanvasY(endPoint.y));
                    } else {
                        const controlX1 = toCanvasX(prev.x) + (toCanvasX(endPoint.x) - toCanvasX(prev.x)) * 0.3;
                        const controlY1 = toCanvasY(prev.y);
                        const controlX2 = toCanvasX(prev.x) + (toCanvasX(endPoint.x) - toCanvasX(prev.x)) * 0.7;
                        const controlY2 = toCanvasY(endPoint.y);
                        ctx.bezierCurveTo(controlX1, controlY1, controlX2, controlY2, toCanvasX(endPoint.x), toCanvasY(endPoint.y));
                    }
                    ctx.stroke();
                    
                    if (current.x > currentMaxX) break;
                }
            }
            
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }
        
        // Animasyonlu nokta çizimi
        function drawAnimatedPoints() {
            if (currentPoints.length === 0) return;
            
            const pointColors = ['#FF5252', '#FF9800', '#4CAF50', '#2196F3', '#9C27B0'];
            const minX = Math.min(...currentPoints.map(p => p.x));
            const maxX = Math.max(...currentPoints.map(p => p.x));
            const currentMaxX = minX + (maxX - minX) * animationProgress;
            
            // X kesim noktalarını çiz
            xIntercepts.forEach(x => {
                if (x <= currentMaxX) {
                    const cx = toCanvasX(x);
                    const cy = toCanvasY(0);
                    
                    ctx.beginPath();
                    ctx.fillStyle = 'rgba(220, 53, 69, 0.3)';
                    ctx.arc(cx + 1, cy + 1, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.arc(cx, cy, 5, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.fillStyle = isInteractiveMode ? '#9C27B0' : '#dc3545';
                    ctx.arc(cx, cy, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // Diğer noktaları çiz
            currentPoints.forEach((point, index) => {
                if (point.x > currentMaxX || point.y === 0) return;
                
                const cx = toCanvasX(point.x);
                const cy = toCanvasY(point.y);
                const pointProgress = Math.min(1, Math.max(0, (currentMaxX - point.x + 1) / 1));
                const alpha = Math.min(1, pointProgress * 2);
                
                if (alpha <= 0) return;
                
                ctx.globalAlpha = alpha * 0.2;
                ctx.beginPath();
                ctx.fillStyle = 'rgba(0, 0, 0, 1)';
                ctx.arc(cx + 1, cy + 1, 4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.arc(cx, cy, 4, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.fillStyle = isInteractiveMode ? '#9C27B0' : pointColors[index];
                ctx.arc(cx, cy, 4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.globalAlpha = 1;
            });
        }
        
        // Normal grafik çizimi (animasyonsuz)
        function drawGraph() {
            drawCoordinateSystem();
            drawContinuousGraph();
            drawXIntercepts();
            drawPoints();
        }
        
        // Sürekli grafik çiz
        function drawContinuousGraph() {
            if (currentPoints.length === 0) return;
            ctx.lineWidth = 4;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 2;
            ctx.shadowOffsetX = 1;
            ctx.shadowOffsetY = 1;

            if (isInteractiveMode) {
                // İnteraktif modda tek mor çizgi
                ctx.beginPath();
                ctx.moveTo(toCanvasX(currentPoints[0].x), toCanvasY(currentPoints[0].y));
                for (let i = 1; i < currentPoints.length; i++) {
                    const prev = currentPoints[i-1];
                    const current = currentPoints[i];
                    if (currentGraphType === 'linear') {
                        ctx.lineTo(toCanvasX(current.x), toCanvasY(current.y));
                    } else {
                        // Bezier eğrisi ile yumuşak geçiş
                        const controlX1 = toCanvasX(prev.x) + (toCanvasX(current.x) - toCanvasX(prev.x)) * 0.3;
                        const controlY1 = toCanvasY(prev.y);
                        const controlX2 = toCanvasX(prev.x) + (toCanvasX(current.x) - toCanvasX(prev.x)) * 0.7;
                        const controlY2 = toCanvasY(current.y);
                        ctx.bezierCurveTo(controlX1, controlY1, controlX2, controlY2, toCanvasX(current.x), toCanvasY(current.y));
                    }
                }
                ctx.strokeStyle = '#9C27B0'; // Mor renk
                ctx.stroke();
            } else {
                // Normal modda renkli segmentler ama yine birleşik
                for (let i = 1; i < currentPoints.length; i++) {
                    const prev = currentPoints[i-1];
                    const current = currentPoints[i];
                    
                    ctx.strokeStyle = getSegmentColor(prev, current);
                    ctx.beginPath();
                    ctx.moveTo(toCanvasX(prev.x), toCanvasY(prev.y));
                    
                    if (currentGraphType === 'linear') {
                        ctx.lineTo(toCanvasX(current.x), toCanvasY(current.y));
                    } else {
                        const controlX1 = toCanvasX(prev.x) + (toCanvasX(current.x) - toCanvasX(prev.x)) * 0.3;
                        const controlY1 = toCanvasY(prev.y);
                        const controlX2 = toCanvasX(prev.x) + (toCanvasX(current.x) - toCanvasX(prev.x)) * 0.7;
                        const controlY2 = toCanvasY(current.y);
                        ctx.bezierCurveTo(controlX1, controlY1, controlX2, controlY2, toCanvasX(current.x), toCanvasY(current.y));
                    }
                    ctx.stroke();
                }
            }

            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }
        
        // X kesim noktalarını çiz
        function drawXIntercepts() {
            xIntercepts.forEach(x => {
                const cx = toCanvasX(x);
                const cy = toCanvasY(0);
                
                ctx.beginPath();
                ctx.fillStyle = 'rgba(220, 53, 69, 0.3)';
                ctx.arc(cx + 1, cy + 1, 5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.arc(cx, cy, 5, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.fillStyle = isInteractiveMode ? '#9C27B0' : '#dc3545';
                ctx.arc(cx, cy, 5, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        // Noktaları çiz
        function drawPoints() {
            const pointColors = ['#FF5252', '#FF9800', '#4CAF50', '#2196F3', '#9C27B0'];
            // Tüm noktaları birleşim noktalarına yerleştir
            currentPoints.forEach((point, index) => {
                const cx = toCanvasX(point.x);
                const cy = toCanvasY(point.y);
                ctx.beginPath();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.arc(cx + 1, cy + 1, 4, 0, Math.PI * 2);
                ctx.fill();

                ctx.beginPath();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.arc(cx, cy, 4, 0, Math.PI * 2);
                ctx.stroke();

                ctx.beginPath();
                ctx.fillStyle = isInteractiveMode ? '#9C27B0' : pointColors[index % pointColors.length];
                ctx.arc(cx, cy, 4, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        // Boş grafik çiz
        function drawEmptyGraph() {
            drawCoordinateSystem();
        }
        
        // Grafik başlığını güncelle
        function updateGraphTitle() {
            const graphTitleElement = document.getElementById('graphTitle');
            if (!graphTitleElement) {
                // Element yoksa hiçbir şey yapma
                return;
            }
            
            let titleText = '';
            if (!isInteractiveMode) {
                titleText = ``; // Boş başlık
            } else {
                const modeText = interactiveFunctionCounter > 5 ? 'Aralık Yazma' : 'Artan/Azalan Seçme';
                titleText = `İnteraktif Egzersiz #${interactiveFunctionCounter} - ${modeText}`;
            }
            
            graphTitleElement.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#1a2a6c" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 3v18h18"></path>
                    <path d="M19 9l-5 5-4-4-3 3"></path>
                </svg>
                ${titleText}
            `;
        }

        // Artan/Azalan analizi için veri hazırlama
        function prepareMonotonicityAnalysis() {
            monotonicityData = [];
            criticalPoints = [];
            
            if (currentPoints.length < 2) return;
            
            // Noktaları x değerine göre sırala
            const sortedPoints = [...currentPoints].sort((a, b) => a.x - b.x);
            
            for (let i = 0; i < sortedPoints.length - 1; i++) {
                const p1 = sortedPoints[i];
                const p2 = sortedPoints[i + 1];
                
                const deltaX = p2.x - p1.x;
                const deltaY = p2.y - p1.y;
                const slope = deltaY / deltaX;
                
                let status = 'constant';
                let statusText = 'SABİT';
                let trendIcon = 'trend-flat';
                
                if (slope > 0.01) {  // Eşik değerini düşürdük
                    status = 'increasing';
                    statusText = 'ARTAN';
                    trendIcon = 'trend-up';
                } else if (slope < -0.01) {  // Eşik değerini düşürdük
                    status = 'decreasing';
                    statusText = 'AZALAN';
                    trendIcon = 'trend-down';
                }
                
                monotonicityData.push({
                    startX: p1.x,
                    endX: p2.x,
                    interval: `[${p1.x}, ${p2.x}]`,
                    status: status,
                    statusText: statusText,
                    trendIcon: trendIcon,
                    slope: slope.toFixed(2)
                });
            }
        }

        // Artan/azalan tablosunu sıfırla
        function resetMonotonicityTable() {
            const tableBody = document.getElementById('monotonicityTableBody');
            
            if (isInteractiveMode) {
                tableBody.innerHTML = `
                    <tr>
                        <td colspan="100%" style="text-align: center; padding: 15px; color: #666;">
                            Grafik çizimi tamamlandıktan sonra S�ra sende tablo burada görüntülenecektir...
                        </td>
                    </tr>
                `;
            } else {
                tableBody.innerHTML = `
                    <tr>
                        <td colspan="100%" style="text-align: center; padding: 15px; color: #666;">
                            Analiz başlıyor...
                        </td>
                    </tr>
                `;
            }
            
            const progressIndicator = document.getElementById('tableProgressIndicator');
            progressIndicator.style.width = '0%';
            
            const analysisSummary = document.getElementById('analysisSummary');
            analysisSummary.innerHTML = '<strong>📊 Analiz Özeti:</strong> Animasyon başladığında dinamik olarak güncellenecektir.';
            
            // Aralık analizini gizle
            const intervalAnalysis = document.getElementById('intervalAnalysis');
            intervalAnalysis.style.display = 'none';
        }

        // Animasyonla senkronize tablo güncelleme
        function updateMonotonicityTableWithAnimation() {
            if (monotonicityData.length === 0) return;
            
            const minX = Math.min(...currentPoints.map(p => p.x));
            const maxX = Math.max(...currentPoints.map(p => p.x));
            const currentMaxX = minX + (maxX - minX) * animationProgress;
            
            // Hangi aralıkların gösterilmesi gerektiğini belirle
            const visibleIntervals = monotonicityData.filter(data => data.startX <= currentMaxX);
            
            if (visibleIntervals.length > 0 && visibleIntervals.length !== currentAnalysisIndex) {
                const tableBody = document.getElementById('monotonicityTableBody');
                
                // Tablo içeriğini temizle
                tableBody.innerHTML = '';
                
                // Aralık satırını oluştur
                const intervalRow = document.createElement('tr');
                intervalRow.className = 'animated-row';
                
                // Durum satırını oluştur
                const statusRow = document.createElement('tr');
                statusRow.className = 'animated-row';
                
                visibleIntervals.forEach((data, index) => {
                    // Aralık hücresi
                    const intervalCell = document.createElement('td');
                    intervalCell.className = 'interval-row';
                    intervalCell.textContent = data.interval;
                    intervalRow.appendChild(intervalCell);
                    
                    // Durum hücresi
                    const statusCell = document.createElement('td');
                    statusCell.className = `status-row ${data.status}`;
                    statusCell.innerHTML = `
                        <span class="trend-icon ${data.trendIcon}"></span>
                        ${data.statusText}
                    `;
                    statusRow.appendChild(statusCell);
                });
                
                tableBody.appendChild(intervalRow);
                tableBody.appendChild(statusRow);
                
                currentAnalysisIndex = visibleIntervals.length;
                updateAnalysisSummary(visibleIntervals);
            }
            
            // Progress indicator güncelle
            const progressIndicator = document.getElementById('tableProgressIndicator');
            progressIndicator.style.width = (animationProgress * 100) + '%';
        }

        // Tabloyu tamamla
        function completeMonotonicityTable() {
            if (monotonicityData.length === 0) return;
            
            currentAnalysisIndex = monotonicityData.length;
            
            const tableBody = document.getElementById('monotonicityTableBody');
            tableBody.innerHTML = '';
            
            // Aralık satırını oluştur
            const intervalRow = document.createElement('tr');
            
            // Sol etiket hücresi - "x"
            const intervalLabelCell = document.createElement('td');
            intervalLabelCell.className = 'interval-row';
            intervalLabelCell.textContent = 'x';
            intervalLabelCell.style.backgroundColor = '#2c3e50';
            intervalLabelCell.style.color = 'white';
            intervalLabelCell.style.fontWeight = 'bold';
            intervalLabelCell.style.fontSize = '12px';
            intervalLabelCell.style.padding = '8px 6px';
            intervalLabelCell.style.textAlign = 'center';
            intervalLabelCell.style.minWidth = '40px';
            intervalRow.appendChild(intervalLabelCell);
            
            // Durum satırını oluştur
            const statusRow = document.createElement('tr');
            
            // Sol etiket hücresi - "f(x)"
            const statusLabelCell = document.createElement('td');
            statusLabelCell.className = 'status-row';
            statusLabelCell.textContent = 'f(x)';
            statusLabelCell.style.backgroundColor = '#34495e';
            statusLabelCell.style.color = 'white';
            statusLabelCell.style.fontWeight = 'bold';
            statusLabelCell.style.fontSize = '12px';
            statusLabelCell.style.padding = '8px 6px';
            statusLabelCell.style.textAlign = 'center';
            statusLabelCell.style.minWidth = '40px';
            statusRow.appendChild(statusLabelCell);
            
            monotonicityData.forEach((data, index) => {
                // Aralık hücresi
                const intervalCell = document.createElement('td');
                intervalCell.className = 'interval-row';
                intervalCell.textContent = data.interval;
                intervalRow.appendChild(intervalCell);
                
                // Durum hücresi
                const statusCell = document.createElement('td');
                statusCell.className = `status-row ${data.status}`;
                statusCell.innerHTML = `
                    <span class="trend-icon ${data.trendIcon}"></span>
                    ${data.statusText}
                `;
                statusRow.appendChild(statusCell);
            });
            
            tableBody.appendChild(intervalRow);
            tableBody.appendChild(statusRow);
            
            updateAnalysisSummary(monotonicityData);
            
            const progressIndicator = document.getElementById('tableProgressIndicator');
            progressIndicator.style.width = '100%';
        }

        // İnteraktif fonksiyon üret
        function generateInteractiveFunction() {
            if (interactiveFunctionCounter >= maxInteractiveFunctions) return;
            
            stopAnimation();
            
            interactiveFunctionCounter++;
            isAnswerCorrect = false;
            nextButtonEnabled = false;
            
            // Önceki geri bildirim mesajlarını temizle
            const feedbackMessage = document.getElementById('feedbackMessage');
            feedbackMessage.style.display = 'none';
            
            // Görev talimatlarını göster
            const taskInstructions = document.getElementById('taskInstructions');
            taskInstructions.style.display = 'block';
            
            updateProgressInfo();
            
            // JSON fonksiyonlarını kullan eğer varsa
            if (interactiveJsonFunctions.length > 0 && currentInteractiveJsonIndex < interactiveJsonFunctions.length) {
                const func = interactiveJsonFunctions[currentInteractiveJsonIndex];
                currentPoints = func.points || [];
                xIntercepts = func.xIntercepts || [];
                currentGraphType = func.graphType || 'curved';
                currentInteractiveJsonIndex++;
            } else if (interactiveJsonFunctions.length > 0 && currentInteractiveJsonIndex >= interactiveJsonFunctions.length) {
                // JSON fonksiyonları bitti, yeniden karıştır
                reshuffleInteractiveFunctions();
                const func = interactiveJsonFunctions[0];
                currentPoints = func.points || [];
                xIntercepts = func.xIntercepts || [];
                currentGraphType = func.graphType || 'curved';
                currentInteractiveJsonIndex = 1;
            } else {
                // Fallback: rastgele fonksiyon üret
                xIntercepts = generateXIntercepts();
                currentPoints = generatePointsFromIntercepts(xIntercepts);
                currentGraphType = Math.random() < 0.4 ? 'linear' : 'curved';
            }
            
            prepareMonotonicityAnalysis();
            currentInteractiveData = [...monotonicityData];
            
            updateGraphTitle();
            createInteractiveTable();
            
            // Yeni egzersizde aralık analizini gizle
            const intervalAnalysis = document.getElementById('intervalAnalysis');
            intervalAnalysis.style.display = 'none';
            
            startDrawAnimation();
        }
        
        // İnteraktif tablo oluştur
        function createInteractiveTable() {
            console.log('Creating interactive table, mode:', isInteractiveMode, 'counter:', interactiveFunctionCounter);
            console.log('Current interactive data:', currentInteractiveData);
            
            const tableBody = document.getElementById('monotonicityTableBody');
            tableBody.innerHTML = '';
            
            if (!currentInteractiveData || currentInteractiveData.length === 0) {
                console.error('No interactive data available');
                tableBody.innerHTML = `
                    <tr>
                        <td colspan="100%" style="text-align: center; padding: 15px; color: #dc3545;">
                            Hata: Analiz verileri bulunamadı!
                        </td>
                    </tr>
                `;
                return;
            }
            
            const isIntervalMode = interactiveFunctionCounter > 5; // İlk 5'i artan/azalan, sonraki 5'i aralık
            console.log('Is interval mode:', isIntervalMode);
            
            if (isIntervalMode) {
                // Aralık yazma modu - kullanıcı hem aralığı hem durumu yazacak
                createIntervalWritingTable(tableBody);
            } else {
                // Artan/Azalan seçme modu - sadece durumu seçecek
                createStatusSelectingTable(tableBody);
            }
            
            updateInteractiveAnalysisSummary();
            console.log('Interactive table creation completed');
        }
        
        // Durum seçme tablosu oluştur
        function createStatusSelectingTable(tableBody) {
            console.log('Creating status selecting table for', currentInteractiveData.length, 'intervals');
            
            // Aralık satırını oluştur (önceden doldurulmuş)
            const intervalRow = document.createElement('tr');
            intervalRow.className = 'interval-row-header';
            
            // Sol etiket hücresi - "ax"
            const intervalLabelCell = document.createElement('td');
            intervalLabelCell.className = 'interval-row';
            intervalLabelCell.textContent = 'x';
            intervalLabelCell.style.backgroundColor = '#2c3e50';
            intervalLabelCell.style.color = 'white';
            intervalLabelCell.style.fontWeight = 'bold';
            intervalLabelCell.style.fontSize = '12px';
            intervalLabelCell.style.padding = '8px 6px';
            intervalLabelCell.style.textAlign = 'center';
            intervalLabelCell.style.minWidth = '40px';
            intervalRow.appendChild(intervalLabelCell);
            
            // Durum satırını oluştur (kullanıcı doldurması için)
            const statusRow = document.createElement('tr');
            statusRow.className = 'status-row-interactive';
            
            // Sol etiket hücresi - "f(x)"
            const statusLabelCell = document.createElement('td');
            statusLabelCell.className = 'status-row';
            statusLabelCell.textContent = 'f(x)';
            statusLabelCell.style.backgroundColor = '#34495e';
            statusLabelCell.style.color = 'white';
            statusLabelCell.style.fontWeight = 'bold';
            statusLabelCell.style.fontSize = '12px';
            statusLabelCell.style.padding = '8px 6px';
            statusLabelCell.style.textAlign = 'center';
            statusLabelCell.style.minWidth = '40px';
            statusRow.appendChild(statusLabelCell);
            
            currentInteractiveData.forEach((data, index) => {
                console.log(`Creating cells for interval ${index}:`, data.interval, data.status);
                
                // Aralık hücresi - önceden doldurulmuş
                const intervalCell = document.createElement('td');
                intervalCell.className = 'interval-row';
                intervalCell.textContent = data.interval;
                intervalCell.style.backgroundColor = '#ff9800';
                intervalCell.style.color = 'white';
                intervalCell.style.fontWeight = 'bold';
                intervalCell.style.fontSize = '11px';
                intervalCell.style.padding = '8px 4px';
                intervalCell.style.textAlign = 'center';
                intervalRow.appendChild(intervalCell);
                
                // Durum hücresi - kullanıcı dolduracak
                const statusCell = document.createElement('td');
                statusCell.className = 'status-row interactive-cell';
                statusCell.style.padding = '5px 2px';
                statusCell.style.backgroundColor = '#f8f9fa';
                statusCell.innerHTML = `
                    <select id="status_${index}" 
                            style="width: 100%; border: 1px solid #ccc; border-radius: 3px; padding: 4px; font-size: 11px; background: white;"
                            >
                        <option value="">-- Seçin --</option>
                        <option value="increasing">ARTAN</option>
                        <option value="decreasing">AZALAN</option>
                        <option value="constant">SABİT</option>
                    </select>
                `;
                statusRow.appendChild(statusCell);
            });
            
            tableBody.appendChild(intervalRow);
            tableBody.appendChild(statusRow);
            
            console.log('Status selecting table created successfully');
        }
        
        // Aralık yazma tablosu oluştur
        function createIntervalWritingTable(tableBody) {
            console.log('Creating interval writing table for', currentInteractiveData.length, 'intervals');
            
            // Aralık satırını oluştur (kullanıcı doldurması için)
            const intervalRow = document.createElement('tr');
            intervalRow.className = 'interval-row-interactive';
            
            // Sol etiket hücresi - "ax"
            const intervalLabelCell = document.createElement('td');
            intervalLabelCell.className = 'interval-row';
            intervalLabelCell.textContent = 'x';
            intervalLabelCell.style.backgroundColor = '#2c3e50';
            intervalLabelCell.style.color = 'white';
            intervalLabelCell.style.fontWeight = 'bold';
            intervalLabelCell.style.fontSize = '12px';
            intervalLabelCell.style.padding = '8px 6px';
            intervalLabelCell.style.textAlign = 'center';
            intervalLabelCell.style.minWidth = '40px';
            intervalRow.appendChild(intervalLabelCell);
            
            // Durum satırını oluştur (kullanıcı doldurması için)
            const statusRow = document.createElement('tr');
            statusRow.className = 'status-row-interactive';
            
            // Sol etiket hücresi - "f(x)"
            const statusLabelCell = document.createElement('td');
            statusLabelCell.className = 'status-row';
            statusLabelCell.textContent = 'f(x)';
            statusLabelCell.style.backgroundColor = '#34495e';
            statusLabelCell.style.color = 'white';
            statusLabelCell.style.fontWeight = 'bold';
            statusLabelCell.style.fontSize = '12px';
            statusLabelCell.style.padding = '8px 6px';
            statusLabelCell.style.textAlign = 'center';
            statusLabelCell.style.minWidth = '40px';
            statusRow.appendChild(statusLabelCell);
            
            currentInteractiveData.forEach((data, index) => {
                console.log(`Creating input cells for interval ${index}:`, data.interval, data.status);
                
                // Aralık hücresi - kullanıcı dolduracak
                const intervalCell = document.createElement('td');
                intervalCell.className = 'interval-row interactive-cell';
                intervalCell.style.backgroundColor = '#fff3e0';
                intervalCell.style.padding = '5px 2px';
                intervalCell.innerHTML = `
                    <input type="text" 
                           id="interval_${index}" 
                           placeholder="[a,b]" 
                           style="width: 100%; border: 1px solid #ccc; border-radius: 3px; padding: 4px; font-size: 11px; text-align: center; background: white;">
                `;
                intervalRow.appendChild(intervalCell);
                
                // Durum hücresi - kullanıcı dolduracak
                const statusCell = document.createElement('td');
                statusCell.className = 'status-row interactive-cell';
                statusCell.style.padding = '5px 2px';
                statusCell.style.backgroundColor = '#f8f9fa';
                statusCell.innerHTML = `
                    <select id="status_${index}" 
                            style="width: 100%; border: 1px solid #ccc; border-radius: 3px; padding: 4px; font-size: 11px; background: white;"
                            >
                        <option value="">-- Seçin --</option>
                        <option value="increasing">ARTAN</option>
                        <option value="decreasing">AZALAN</option>
                        <option value="constant">SABİT</option>
                    </select>
                `;
                statusRow.appendChild(statusCell);
            });
            
            tableBody.appendChild(intervalRow);
            tableBody.appendChild(statusRow);
            
            console.log('Interval writing table created successfully');
        }
        
        // Cevapları kontrol et
        function checkAnswer() {
            const isIntervalMode = interactiveFunctionCounter > 5;
            let allFilled = true;
            let allCorrect = true;
            const feedbackMessage = document.getElementById('feedbackMessage');
            
            // Tüm giriş alanlarını kontrol et
            currentInteractiveData.forEach((data, index) => {
                let userIntervalAnswer = '';
                let userStatusAnswer = '';
                
                if (isIntervalMode) {
                    // Aralık yazma modu
                    const intervalInput = document.getElementById(`interval_${index}`);
                    const statusSelect = document.getElementById(`status_${index}`);
                    
                    if (intervalInput && statusSelect) {
                        userIntervalAnswer = intervalInput.value.trim();
                        userStatusAnswer = statusSelect.value;
                        
                        if (!userIntervalAnswer || !userStatusAnswer) {
                            allFilled = false;
                            return;
                        }
                        
                        // Aralık kontrolü
                        const cleanUserInterval = userIntervalAnswer.replace(/\s/g, '');
                        const cleanCorrectInterval = data.interval.replace(/\s/g, '');
                        const intervalCorrect = cleanUserInterval === cleanCorrectInterval;
                        
                        // Durum kontrolü
                        const statusCorrect = userStatusAnswer === data.status;
                        
                        // Görsel geri bildirim
                        const intervalCell = intervalInput.parentElement;
                        const statusCell = statusSelect.parentElement;
                        
                        if (intervalCorrect) {
                            intervalCell.style.backgroundColor = '#d4edda';
                            intervalCell.style.border = '2px solid #28a745';
                        } else {
                            intervalCell.style.backgroundColor = '#f8d7da';
                            intervalCell.style.border = '2px solid #dc3545';
                            allCorrect = false;
                        }
                        
                        if (statusCorrect) {
                            statusCell.style.backgroundColor = '#d4edda';
                            statusCell.style.border = '2px solid #28a745';
                        } else {
                            statusCell.style.backgroundColor = '#f8d7da';
                            statusCell.style.border = '2px solid #dc3545';
                            allCorrect = false;
                        }
                    }
                } else {
                    // Durum seçme modu
                    const statusSelect = document.getElementById(`status_${index}`);
                    
                    if (statusSelect) {
                        userStatusAnswer = statusSelect.value;
                        
                        if (!userStatusAnswer) {
                            allFilled = false;
                            return;
                        }
                        
                        const statusCorrect = userStatusAnswer === data.status;
                        const statusCell = statusSelect.parentElement;
                        
                        if (statusCorrect) {
                            statusCell.style.backgroundColor = '#d4edda';
                            statusCell.style.border = '2px solid #28a745';
                        } else {
                            statusCell.style.backgroundColor = '#f8d7da';
                            statusCell.style.border = '2px solid #dc3545';
                            allCorrect = false;
                        }
                    }
                }
            });
            
            // Geri bildirim mesajını göster
            feedbackMessage.style.display = 'block';
            
            if (!allFilled) {
                feedbackMessage.innerHTML = `
                    <strong>📝 Devam edin...</strong><br>
                    Lütfen tüm alanları doldurunuz.
                `;
                feedbackMessage.style.backgroundColor = '#fff3cd';
                feedbackMessage.style.color = '#856404';
                feedbackMessage.style.border = '1px solid #ffeaa7';
                isAnswerCorrect = false;
                nextButtonEnabled = false;
            } else if (allCorrect) {
                feedbackMessage.innerHTML = `
                    <strong>🎉 Mükemmel!</strong><br>
                    Tüm cevaplarınız doğru! Bir sonraki soruya geçebilirsiniz.
                `;
                feedbackMessage.style.backgroundColor = '#d4edda';
                feedbackMessage.style.color = '#155724';
                feedbackMessage.style.border = '1px solid #c3e6cb';
                isAnswerCorrect = true;
                nextButtonEnabled = true;
                
                // Doğru cevap verildikten sonra en geniş aralık analizini göster
                calculateIntervalSets(currentInteractiveData);
            } else {
                feedbackMessage.innerHTML = `
                    <strong>⚠️ Tekrar deneyin!</strong><br>
                    Bazı cevaplarınız yanlış. Kırmızı işaretli alanları kontrol ediniz.
                `;
                feedbackMessage.style.backgroundColor = '#f8d7da';
                feedbackMessage.style.color = '#721c24';
                feedbackMessage.style.border = '1px solid #f5c6cb';
                isAnswerCorrect = false;
                nextButtonEnabled = false;
            }
            
            updateProgressInfo();
        }
        
        // İnteraktif analiz özetini güncelle
        function updateInteractiveAnalysisSummary() {
            const analysisSummary = document.getElementById('analysisSummary');
            const isIntervalMode = interactiveFunctionCounter > 5;
            
            if (isIntervalMode) {
                analysisSummary.innerHTML = `
                    <strong>📝 Egzersiz ${interactiveFunctionCounter} - Aralık Yazma:</strong><br>
                    Aralıkları ve durumları (ARTAN/AZALAN/SABİT) doldurun, sonra "Kontrol Et" butonuna tıklayın.
                `;
            } else {
                analysisSummary.innerHTML = `
                    <strong>📝 Egzersiz ${interactiveFunctionCounter} - Durum Seçme:</strong><br>
                    Her aralık için ARTAN, AZALAN veya SABİT durumunu seçin, sonra "Kontrol Et" butonuna tıklayın.
                `;
            }
            
            analysisSummary.style.backgroundColor = '#e3f2fd';
            analysisSummary.style.color = '#1565c0';
            analysisSummary.style.border = '1px solid #90caf9';
            
            // Görev talimatlarını güncelle
            updateTaskInstructions();
            
            // İnteraktif modda başlangıçta aralık analizini gizle
            const intervalAnalysis = document.getElementById('intervalAnalysis');
            intervalAnalysis.style.display = 'none';
        }
        
        // Görev talimatlarını güncelle
        function updateTaskInstructions() {
            const taskContent = document.getElementById('taskContent');
            const isIntervalMode = interactiveFunctionCounter > 5;
            
            if (isIntervalMode) {
                taskContent.innerHTML = `
                    <div style="margin-bottom: 12px;">
                        <strong style="color: #dc3545;">📐 Aralık Yazma Modu</strong>
                    </div>
                    <ul style="margin: 0; padding-left: 20px; list-style-type: none;">
                        <li style="margin-bottom: 8px;">
                            <span style="color: #28a745; font-weight: bold;">1️⃣</span> 
                            Yukarıdaki <strong>mor fonksiyon grafiğini</strong> inceleyiniz
                        </li>
                        <li style="margin-bottom: 8px;">
                            <span style="color: #28a745; font-weight: bold;">2️⃣</span> 
                            Tablodaki <strong>boş aralık kutularına</strong> fonksiyonun monotonluk aralıklarını yazınız<br>
                            <small style="color: #6c757d; margin-left: 20px;">Örnek: [-3, 1], [1, 4] şeklinde</small>
                        </li>
                        <li style="margin-bottom: 8px;">
                            <span style="color: #28a745; font-weight: bold;">3️⃣</span> 
                            Her aralık için <strong>açılır menüden</strong> durumu seçiniz:
                            <ul style="margin-top: 4px; margin-left: 15px; list-style-type: disc;">
                                <li><strong style="color: #28a745;">ARTAN:</strong> Fonksiyon yukarı doğru gidiyor</li>
                                <li><strong style="color: #dc3545;">AZALAN:</strong> Fonksiyon aşağı doğru gidiyor</li>
                                <li><strong style="color: #17a2b8;">SABİT:</strong> Fonksiyon düz gidiyor</li>
                            </ul>
                        </li>
                        <li style="margin-bottom: 0;">
                            <span style="color: #28a745; font-weight: bold;">4️⃣</span> 
                            <strong>"Kontrol Et"</strong> butonuna tıklayarak cevaplarınızı kontrol ediniz
                        </li>
                    </ul>
                `;
            } else {
                taskContent.innerHTML = `
                    <div style="margin-bottom: 12px;">
                        <strong style="color: #007bff;">🎯 Durum Seçme Modu</strong>
                    </div>
                    <ul style="margin: 0; padding-left: 20px; list-style-type: none;">
                        <li style="margin-bottom: 8px;">
                            <span style="color: #28a745; font-weight: bold;">1️⃣</span> 
                            Yukarıdaki <strong>mor fonksiyon grafiğini</strong> dikkatli bir şekilde inceleyiniz
                        </li>
                        <li style="margin-bottom: 8px;">
                            <span style="color: #28a745; font-weight: bold;">2️⃣</span> 
                            Tabloda <strong>turuncu renkli aralıklar</strong> verilmiştir
                        </li>
                        <li style="margin-bottom: 8px;">
                            <span style="color: #28a745; font-weight: bold;">3️⃣</span> 
                            Her aralık için <strong>açılır menüden</strong> doğru durumu seçiniz:
                            <ul style="margin-top: 4px; margin-left: 15px; list-style-type: disc;">
                                <li><strong style="color: #28a745;">ARTAN:</strong> Soldan sağa fonksiyon değeri artıyor</li>
                                <li><strong style="color: #dc3545;">AZALAN:</strong> Soldan sağa fonksiyon değeri azalıyor</li>
                                <li><strong style="color: #17a2b8;">SABİT:</strong> Fonksiyon değeri değişmiyor</li>
                            </ul>
                        </li>
                        <li style="margin-bottom: 0;">
                            <span style="color: #28a745; font-weight: bold;">4️⃣</span> 
                            <strong>"Kontrol Et"</strong> butonuna tıklayarak cevaplarınızı kontrol ediniz
                        </li>
                    </ul>
                `;
            }
        }

        // Analiz özetini güncelle
        function updateAnalysisSummary(visibleData) {
            const analysisSummary = document.getElementById('analysisSummary');
            
            const increasingCount = visibleData.filter(d => d.status === 'increasing').length;
            const decreasingCount = visibleData.filter(d => d.status === 'decreasing').length;
            const constantCount = visibleData.filter(d => d.status === 'constant').length;
            
            const totalVisible = visibleData.length;
            const totalIntervals = monotonicityData.length;
            
            let summary = `<strong>📊 Fonksiyon #${functionCounter} Analizi:</strong> `;
            
            if (totalVisible < totalIntervals) {
                summary += `(${totalVisible}/${totalIntervals} aralık) `;
            } else {
                summary += `(Tamamlandı) `;
            }
            
            summary += `<br>`;
            
            if (increasingCount > 0) {
                summary += `↗️ ${increasingCount} artan `;
            }
            
            if (decreasingCount > 0) {
                summary += `↘️ ${decreasingCount} azalan `;
            }
            
            if (constantCount > 0) {
                summary += `➡️ ${constantCount} sabit `;
            }
            
            summary += `aralık`;
            
            analysisSummary.innerHTML = summary;
            
            // En geniş aralık analizi (normal modda tamamlandığında veya S�ra sende modunda doğru cevap verildikten sonra)
            if ((!isInteractiveMode && totalVisible === totalIntervals) || (isInteractiveMode && isAnswerCorrect)) {
                calculateIntervalSets(visibleData);
            }
        }
        
        // Aralık kümelerini hesapla
        function calculateIntervalSets(data) {
            const intervalAnalysis = document.getElementById('intervalAnalysis');
            const longestIncreasing = document.getElementById('longestIncreasing');
            const longestDecreasing = document.getElementById('longestDecreasing');
            const longestConstant = document.getElementById('longestConstant');
            
            // Her tip için aralıkları topla ve birleştir
            const increasingIntervals = mergeConsecutiveIntervals(data.filter(d => d.status === 'increasing'));
            const decreasingIntervals = mergeConsecutiveIntervals(data.filter(d => d.status === 'decreasing'));
            const constantIntervals = mergeConsecutiveIntervals(data.filter(d => d.status === 'constant'));
            
            // Önce tüm divleri gizle
            longestIncreasing.style.display = 'none';
            longestDecreasing.style.display = 'none';
            longestConstant.style.display = 'none';
            
            let hasAnyInterval = false;
            
            // Sonuçları küme birleşimi olarak göster (sadece bulunanlar için)
            if (increasingIntervals.length > 0) {
                const unionText = increasingIntervals.join(' ∪ ');
                longestIncreasing.innerHTML = `↗️ <strong>Artan aralıklar:</strong> ${unionText}`;
                longestIncreasing.style.color = '#28a745';
                longestIncreasing.style.display = 'block';
                hasAnyInterval = true;
            }
            
            if (decreasingIntervals.length > 0) {
                const unionText = decreasingIntervals.join(' ∪ ');
                longestDecreasing.innerHTML = `↘️ <strong>Azalan aralıklar:</strong> ${unionText}`;
                longestDecreasing.style.color = '#dc3545';
                longestDecreasing.style.display = 'block';
                hasAnyInterval = true;
            }
            
            if (constantIntervals.length > 0) {
                const unionText = constantIntervals.join(' ∪ ');
                longestConstant.innerHTML = `➡️ <strong>Sabit aralıklar:</strong> ${unionText}`;
                longestConstant.style.color = '#17a2b8';
                longestConstant.style.display = 'block';
                hasAnyInterval = true;
            }
            
            // En az bir aralık varsa analiz bölümünü göster
            if (hasAnyInterval) {
                intervalAnalysis.style.display = 'block';
            } else {
                intervalAnalysis.style.display = 'none';
            }
        }
        
        // Ardışık aralıkları birleştir
        function mergeConsecutiveIntervals(intervals) {
            if (intervals.length === 0) return [];
            
            // Aralıkları başlangıç X değerine göre sırala
            intervals.sort((a, b) => a.startX - b.startX);
            
            const merged = [];
            let currentStart = intervals[0].startX;
            let currentEnd = intervals[0].endX;
            
            for (let i = 1; i < intervals.length; i++) {
                const interval = intervals[i];
                
                // Eğer bu aralık bir öncekinin bittiği yerden başlıyorsa birleştir
                if (interval.startX === currentEnd) {
                    currentEnd = interval.endX;
                } else {
                    // Yeni birleştirilmiş aralığı ekle
                    merged.push(`[${currentStart}, ${currentEnd}]`);
                    currentStart = interval.startX;
                    currentEnd = interval.endX;
                }
            }
            
            // Son aralığı ekle
            merged.push(`[${currentStart}, ${currentEnd}]`);
            
            return merged;
        }
    </script>
</body>
</html>
