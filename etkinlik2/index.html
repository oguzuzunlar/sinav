<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="icon" href="data:,">
    <title>Harezmi Y√∂ntemiyle Tam Kareye Tamamlama</title>
    <style>
    @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700;800&family=Inter:wght@400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap');
        
        :root { 
            --primary-color: #2563eb; 
            --primary-light: #3b82f6; 
            --primary-dark: #1d4ed8;
            --secondary-color: #0f172a; 
            --light-gray: #f8fafc; 
            --gray: #e2e8f0; 
            --success-color: #16a34a;
            --success-light: #22c55e;
            --warning-color: #f59e0b;
            --danger-color: #dc2626;
            --text-muted: #0b2447; /* darker / deep navy for better readability (was #374151) */
            --text-strong: #06122b; /* very strong text color used for key info areas */
            --border-color: #cbd5e1;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
            --border-radius: 8px;
            --border-radius-lg: 12px;
            --transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Kid-friendly palette and panel styles */
        :root {
            --kid-1: #ffde59; /* sunny yellow */
            --kid-2: #ffd1dc; /* soft pink */
            --kid-3: #7ee3b9; /* mint */
            --kid-4: #60a5fa; /* sky blue */
            --kid-accent: #ff6b6b; /* coral */
            --kid-accent-2: #8b5cf6; /* violet */
            --kid-panel-shadow: 0 10px 30px rgba(99,102,241,0.12);
        }
        
        * { box-sizing: border-box; }
        
        body { 
            font-family: 'Poppins', 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; 
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            color: var(--secondary-color); 
            margin: 0; 
            display: flex; 
            justify-content: center; 
            align-items: flex-start; 
            min-height: 100vh; 
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            overflow-x: hidden;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        .container { 
            width: 95%; 
            max-width: 1400px; 
            background: linear-gradient(145deg, #ffffff, #f8fafc);
            border-radius: 20px; 
            box-shadow: var(--shadow-xl);
            overflow: visible; 
            margin: 20px;
            border: 1px solid var(--border-color);
            backdrop-filter: blur(10px);
            min-height: auto;
        }
        
        .screen { 
            padding: 40px 50px; 
            text-align: center; 
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
        }

        /* Colorful panels for kid-friendly look */
        #intro-screen {
            background: linear-gradient(135deg, var(--kid-4), var(--kid-1));
            color: #07223a;
            border-radius: 20px;
            padding: 40px 30px;
            box-shadow: var(--kid-panel-shadow);
            border: 4px solid rgba(255,255,255,0.6);
        }
        
        #activity-screen { 
            display: none; 
            padding: 20px 15px; 
            background: linear-gradient(135deg, #fafbff 0%, #f1f5f9 100%);
        }
        
        h1, h2, h3 {
            font-weight: 800;
            letter-spacing: -0.02em;
            color: var(--secondary-color);
            text-shadow: 0 1px 0 rgba(255,255,255,0.6);
        }

        h1 {
            font-size: clamp(2.2rem, 4.5vw, 3rem);
            color: var(--primary-dark);
            margin-bottom: 1.25rem;
            background: none;
            -webkit-background-clip: unset;
            background-clip: unset;
            -webkit-text-fill-color: unset;
        }

        h2 {
            font-size: clamp(1.6rem, 3.2vw, 2.2rem);
            margin-bottom: 0.9rem;
            color: var(--secondary-color);
        }

        h3 {
            font-size: clamp(1.25rem, 2.6vw, 1.6rem);
            margin-top: 0;
            margin-bottom: 0.9rem;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 12px;
            color: var(--secondary-color);
        }
        p {
            font-size: clamp(1.05rem, 2.1vw, 1.2rem);
            line-height: 1.7;
            max-width: 800px;
            margin: 0 auto 1.5rem;
            color: var(--secondary-color);
        }

        /* Improve contrast for highlighted informational regions (per screenshot)
           - intro paragraph, info column, and injected stage descriptions should be more vivid
        */
        #intro-screen p,
        #info-content p,
        #stage-description-container p,
        #stage-description-container .hint,
        .mobile-navigation .stage-note,
        .info-column p {
            color: var(--text-strong);
            font-weight: 600;
        }
        
        .btn { 
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background: linear-gradient(135deg, var(--primary-color), var(--primary-light)); 
            color: white; 
            padding: 14px 28px; 
            border: none; 
            border-radius: var(--border-radius-lg); 
            font-size: 1rem; 
            font-weight: 600; 
            cursor: pointer; 
            text-decoration: none; 
            transition: var(--transition);
            box-shadow: var(--shadow-md);
            position: relative;
            overflow: hidden;
            font-family: inherit;
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.6s;
        }
        
        .btn:hover::before {
            left: 100%;
        }
        
        .btn:hover { 
            transform: translateY(-2px); 
            box-shadow: var(--shadow-lg);
            background: linear-gradient(135deg, var(--primary-light), var(--primary-color));
        }
        
        .btn:active {
            transform: translateY(0);
            transition: var(--transition);
        }
        .activity-layout { 
            display: grid; 
            grid-template-columns: 1.6fr 0.6fr; 
            gap: 20px; 
            width: 100%; 
            align-items: start;
        }
        
        .canvas-column { 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            background: linear-gradient(145deg, #ffffff, #f8fafc);
            border: 2px solid var(--border-color); 
            border-radius: var(--border-radius-lg); 
            min-height: 520px; 
            position: relative;
            box-shadow: var(--shadow-md);
            overflow: hidden;
            padding: 8px;
        }
        
        .canvas-column::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at center, rgba(37, 99, 235, 0.02) 0%, transparent 50%);
            pointer-events: none;
        }
        
        .info-column { 
            text-align: left; 
            padding: 20px;
            background: linear-gradient(135deg, var(--kid-2), var(--kid-3));
            border-radius: 18px;
            box-shadow: var(--kid-panel-shadow);
            border: 3px solid rgba(255,255,255,0.6);
            color: #07223a;
        }
        #info-content p { 
            margin: 0 0 1.5rem 0; 
            max-width: none; 
            font-size: 1rem;
            line-height: 1.6;
            color: var(--secondary-color); /* make info text darker and more vivid */
        }
        
        .solution-steps { 
            background: linear-gradient(135deg, #fff7cc, #ffe6f0);
            border-left: 8px solid var(--kid-accent-2); 
            border-radius: 12px;
            padding: 18px; 
            margin: 1.5rem 0; 
            font-family: 'JetBrains Mono', 'Courier New', Courier, monospace; 
            font-size: 1.2rem; 
            line-height: 1.6;
            box-shadow: var(--kid-panel-shadow);
            position: relative;
            overflow: hidden;
            color: #0b2447; /* deep navy for contrast */
        }
        
        .solution-steps::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(180deg, var(--primary-color), var(--primary-light));
        }
        
        .historical-note { 
            font-size: 1rem; 
            color: #0b2447; 
            margin-top: 1rem;
            padding: 18px;
            background: linear-gradient(135deg, #fef7cd, #ffd9d9);
            border-radius: 12px;
            border-left: 6px solid var(--warning-color);
            box-shadow: var(--kid-panel-shadow);
        }
        .navigation { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            margin-top: 2rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
        }
        
        .mobile-navigation {
            display: none;
            justify-content: space-between;
            align-items: center;
            margin: 15px 0;
            padding: 15px 20px;
            background: linear-gradient(145deg, #ffffff, #f8fafc);
            border-radius: var(--border-radius-lg);
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border-color);
        }

        .desktop-navigation, .mobile-navigation {
            background: linear-gradient(135deg, var(--kid-4), var(--kid-3));
            color: #06122b;
            border: 2px solid rgba(255,255,255,0.6);
            box-shadow: var(--kid-panel-shadow);
        }
        
        .desktop-navigation {
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            margin-top: 2rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
        }
        
        @media (min-width: 769px) {
            .mobile-navigation {
                display: none !important;
            }
        }
        
        .btn-nav { 
            background: linear-gradient(145deg, #ffffff, #f1f5f9);
            color: var(--secondary-color); 
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border-color);
            font-weight: 500;
            /* YENƒ∞ EKLENEN/DEƒûƒ∞≈ûEN KOD */
            padding: 10px 16px; /* Buton boyutunu k√º√ß√ºlt√ºr */
            font-size: 0.9rem; /* Yazƒ± boyutunu k√º√ß√ºlt√ºr */
            white-space: nowrap; /* ƒ∞√ßindeki metnin alt satƒ±ra ge√ßmesini engeller */
        }

        /* Bitir butonu i√ßin ba≈üarƒ±lƒ± (ye≈üil) tema */
        .btn-finish {
            background: linear-gradient(135deg, var(--success-color), var(--success-light));
            color: #ffffff;
            border-color: rgba(34, 197, 94, 0.4);
        }

        .btn-finish:hover {
            background: linear-gradient(135deg, var(--success-light), var(--success-color));
        }
        
        .btn-nav:hover { 
            background: linear-gradient(145deg, #f8fafc, #e2e8f0);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }
        
        .btn-nav:disabled { 
            background: #f8fafc; 
            border-color: var(--gray); 
            /* YENƒ∞ EKLENEN/DEƒûƒ∞≈ûEN KOD */
            color: var(--text-muted); /* Daha okunaklƒ± bir pasif renk */
            cursor: not-allowed; 
            opacity: 0.7; /* Opaklƒ±ƒüƒ± biraz artƒ±rarak okunurluƒüu iyile≈ütirir */
            transform: none;
            box-shadow: none;
        }
        
        #stage-indicator {
            font-weight: 600;
            color: var(--text-muted);
            background: linear-gradient(145deg, #f8fafc, #e2e8f0);
            padding: 8px 16px;
            border-radius: var(--border-radius);
            border: 1px solid var(--border-color);
            font-size: 0.9rem;
            white-space: nowrap; /* A≈üama yazƒ±sƒ±nƒ±n alt satƒ±ra ge√ßmesini engeller */
            display: inline-block;
            text-align: center; /* ensure children are centered */
        }

        /* Two-line stage indicator: top label + fraction below */
        .stage-fraction {
            display: block;
            font-size: 0.95rem;
            color: var(--secondary-color);
            font-weight: 700;
            line-height: 1;
            margin-top: 2px;
            text-align: center; /* center the fraction text */
        }
        
        #geometry-canvas { 
            max-width: 100%; 
            height: auto; 
            cursor: grab;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-sm);
        }
        
        #geometry-canvas:active {
            cursor: grabbing;
        }
        .badge { 
            display: inline-flex;
            align-items: center;
            padding: 6px 12px; 
            border-radius: 20px; 
            font-size: 0.8rem; 
            font-weight: 600; 
            line-height: 1; 
            vertical-align: middle;
            box-shadow: var(--shadow-sm);
        }
        
        .badge-part { 
            background: linear-gradient(90deg, var(--kid-accent-2), var(--kid-accent));
            color: #fff; 
            border: none;
        }
        
        h3 .badge { 
            margin-left: 12px; 
        }
        
        .loading-dots {
            display: inline-block;
        }
        
        .loading-dots::after {
            content: '';
            animation: dots 1.5s steps(4, end) infinite;
        }
        
        @keyframes dots {
            0%, 20% { content: ''; }
            40% { content: '.'; }
            60% { content: '..'; }
            80%, 100% { content: '...'; }
        }
        
        .success-feedback {
            background: linear-gradient(145deg, #dcfce7, #bbf7d0);
            border: 1px solid var(--success-color);
            border-radius: var(--border-radius);
            padding: 12px 16px;
            color: #166534;
            font-weight: 500;
            margin: 1rem 0;
            animation: slideInUp 0.3s ease-out;
        }
        
        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .drag-hint {
            position: absolute;
            top: 10px;
            right: 15px;
            background: rgba(37, 99, 235, 0.9);
            color: white;
            padding: 6px 12px;
            border-radius: var(--border-radius);
            font-size: 0.8rem;
            font-weight: 500;
            z-index: 10;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
        /* Make inline mathematical expressions in text more prominent */
        .math-expression, code.math-expression {
            color: #06122b; /* deep navy for contrast */
            font-weight: 700;
        }
        /* Also make inline <code> in paragraphs, info panels and solution boxes darker/bold so math stands out */
        p code,
        #info-content code,
        .solution-steps code,
        .historical-note code,
        .activity-layout code {
            color: #06122b;
            font-weight: 700;
        }
        @media (max-width: 1024px) { 
            .activity-layout { 
                grid-template-columns: 1fr; 
                gap: 20px;
            } 
            .canvas-column { 
                min-height: 400px; 
                order: 1;
            } 
            .info-column { 
                padding: 20px;
                order: 2;
            } 
        }
        
        @media (max-width: 768px) { 
            body {
                align-items: flex-start;
                padding: 10px 0;
                min-height: 100vh;
            }
            
            .container {
                width: 98%;
                margin: 10px;
                border-radius: 16px;
                min-height: calc(100vh - 20px);
                overflow: visible;
            }
            
            .screen { 
                padding: 20px 15px; 
            }
            
            #activity-screen {
                padding: 15px 10px;
                min-height: calc(100vh - 30px);
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .activity-layout {
                grid-template-columns: 1fr;
                gap: 0;
                min-height: auto;
            }
            
            .canvas-column { 
                min-height: 300px; 
                padding: 10px;
                margin-bottom: 0;
                touch-action: none;
            } 
            
            #geometry-canvas {
                touch-action: none;
                -webkit-user-select: none;
                user-select: none;
            }
            
            .mobile-navigation {
                display: flex !important;
                margin: 15px 10px 20px 10px;
                touch-action: manipulation;
                /* Ensure high contrast for stage indicator on mobile */
                background: linear-gradient(145deg, var(--primary-color), #2563eb);
                color: white;
            }
            
            .desktop-navigation {
                display: none !important;
            }
            
            .info-column { 
                padding: 15px 10px; 
                max-height: none;
                overflow: visible;
            } 
            
            h1 { 
                font-size: 1.6rem; 
                margin-bottom: 1rem;
            } 
            
            h2 { 
                font-size: 1.5rem; 
            } 
            
            p { 
                font-size: 1rem; 
            }
            
            .btn {
                padding: 12px 20px;
                font-size: 0.9rem;
            }
            
            .mobile-navigation {
                flex-direction: column;
                gap: 15px;
                margin: 15px 15px 20px 15px;
                border: 2px solid var(--primary-color);
                background: linear-gradient(145deg, var(--primary-color), #2563eb);
                color: white;
            }
            
            .mobile-navigation button {
                width: 100%;
                justify-content: center;
                background: rgba(255, 255, 255, 0.15);
                border: 1px solid rgba(255, 255, 255, 0.3);
                color: white; /* Metin rengi beyaz */
                font-weight: 600;
            }
            
            /* YENƒ∞ EKLENEN KOD */
            .mobile-navigation button:disabled {
                background: rgba(255, 255, 255, 0.1);
                color: rgba(255, 255, 255, 0.5); /* Pasif durumdaki metni daha okunaklƒ± yapar */
                cursor: not-allowed;
                transform: none;
                box-shadow: none;
                opacity: 1; /* Ana pasif stilini ezer */
            }

            .mobile-navigation button:hover {
                background: rgba(255, 255, 255, 0.25);
            }
            
            /* Make the stage indicator box itself readable: light card with dark text */
            .mobile-navigation #stage-indicator {
                background: #ffffff; /* solid white card */
                color: #06122b; /* dark navy text for contrast */
                font-weight: 800;
                padding: 10px 14px;
                border-radius: 12px;
                border: 1px solid rgba(6,18,43,0.06);
                box-shadow: 0 6px 18px rgba(2,6,23,0.12);
                display: inline-block;
                line-height: 1.05;
                text-align: center;
                min-width: 54px;
            }
            .mobile-navigation #stage-indicator .stage-fraction {
                color: rgba(6,18,43,0.85);
                font-weight: 700;
                display: block;
                margin-top: 2px;
                font-size: 0.95rem;
            }
        }
        
        @media (max-width: 480px) {
            body {
                padding: 5px 0;
            }
            
            .container {
                width: 100%;
                margin: 5px;
                border-radius: 12px;
                min-height: calc(100vh - 10px);
            }
            
            .screen {
                padding: 15px 10px;
            }
            
            #activity-screen {
                padding: 10px 5px;
            }
            
            .canvas-column {
                min-height: 280px;
                padding: 8px;
            }
            
            .mobile-navigation {
                margin: 10px 5px 15px 5px;
                padding: 12px 15px;
                gap: 12px;
            }
            
            .mobile-navigation button {
                padding: 10px 15px;
                font-size: 0.85rem;
            }
            
            .info-column {
                padding: 12px 8px;
            }
            
            h1 {
                font-size: 1.4rem;
            }
            
            h3 {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
                font-size: 1.1rem;
            }
            
            .btn {
                padding: 10px 15px;
                font-size: 0.85rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Giri≈ü Ekranƒ± -->
        <div id="intro-screen" class="screen">
            <h1>üìê Harezmi Y√∂ntemiyle Tam Kareye Tamamlama</h1>
            <p>√únl√º matematik√ßi <strong>Harezmi</strong>, ikinci dereceden denklemleri g√ºn√ºm√ºzdeki form√ºller yerine, alan hesaplamalarƒ±na dayanan pratik bir geometrik y√∂ntemle √ß√∂z√ºyordu. Bu y√∂ntem, matematiƒüin en temel konularƒ±ndan birine ismini vermi≈ütir: <strong>Tam Kareye Tamamlama</strong>.</p>
            
            <div style="background: linear-gradient(145deg, #f0f9ff, #e0f2fe); border-radius: 12px; padding: 20px; margin: 2rem auto; max-width: 700px; border-left: 4px solid var(--primary-color);">
                <p style="margin: 0; font-weight: 500; color: var(--secondary-color);">Bu etkinlikte, <strong class="math-expression">x¬≤ + 10x = 39</strong> denklemini Harezmi‚Äônin geli≈ütirdiƒüi  tam kare olu≈üturma y√∂ntemini adƒ±m adƒ±m izleyerek √ß√∂zeceƒüiz.
. Amacƒ±mƒ±z, denklemin sol tarafƒ±ndaki <code style="background: rgba(37, 99, 235, 0.1); padding: 2px 6px; border-radius: 4px; font-family: 'JetBrains Mono', monospace;">x¬≤</code> ve <code style="background: rgba(37, 99, 235, 0.1); padding: 2px 6px; border-radius: 4px; font-family: 'JetBrains Mono', monospace;">10x</code> ifadelerini temsil eden geometrik ≈üekilleri kullanarak eksik par√ßayƒ± bulup <strong>tam bir kare</strong> olu≈üturmaktƒ±r.</p>
            </div>
            
                <p>"Tam Kareye Tamamlama" y√∂nteminin isminin nereden geldiƒüini ve denklemlerin ardƒ±ndaki geometrik mantƒ±ƒüƒ± bizzat g√∂rerek √∂ƒürenmeye hazƒ±r mƒ±sƒ±n?</p>
            
            <button id="start-btn" class="btn">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M8 5L19 12L8 19V5Z" fill="currentColor"/>
                </svg>
                Etkinliƒüe Ba≈üla!
            </button>
        </div>

        <!-- Etkinlik Ekranƒ± -->
        <div id="activity-screen" class="screen">
            <div class="activity-layout">
                <div class="canvas-column">
                    <canvas id="geometry-canvas"></canvas>
                </div>
                <!-- Mobil Navigasyon -->
                <div class="mobile-navigation">
                    <button id="prev-btn" class="btn btn-nav">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M15 18L9 12L15 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                        Geri
                    </button>
                    <span id="stage-indicator">A≈üama<br><span class="stage-fraction">1 / 4</span></span>
                    <button id="next-btn" class="btn btn-nav">
                        ƒ∞leri
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M9 18L15 12L9 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </button>
                    <!-- Etkinlik bittiƒüinde g√∂r√ºnecek Bitir butonu -->
                    <button id="finish-btn" class="btn btn-nav btn-finish" style="display: none;">
                        Bitir
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M5 13l4 4L19 7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </button>
                </div>
                <div class="info-column">
                    <div id="info-content">
                        <h3 id="stage-title">Ba≈ülƒ±k</h3>
                        <div id="stage-description-container"></div>
                        <div id="success-message" class="success-feedback" style="display: none;">
                            ‚úÖ Harika! Bir sonraki adƒ±ma ge√ßebilirsin.
                        </div>
                    </div>
                    <!-- Masa√ºst√º Navigasyon -->
                    <div class="desktop-navigation">
                        <button id="prev-btn-desktop" class="btn btn-nav">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M15 18L9 12L15 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                            Geri
                        </button>
                        <span id="stage-indicator-desktop">A≈üama<br><span class="stage-fraction">1 / 4</span></span>
                        <button id="next-btn-desktop" class="btn btn-nav">
                            ƒ∞leri
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M9 18L15 12L9 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                        </button>
                        <!-- Masa√ºst√º i√ßin Bitir butonu -->
                        <button id="finish-btn-desktop" class="btn btn-nav btn-finish" style="display: none;">
                            Bitir
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M5 13l4 4L19 7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const screens = { intro: document.getElementById('intro-screen'), activity: document.getElementById('activity-screen') };
            const buttons = { 
                start: document.getElementById('start-btn'), 
                next: document.getElementById('next-btn'), 
                prev: document.getElementById('prev-btn'), 
                nextDesktop: document.getElementById('next-btn-desktop'), 
                prevDesktop: document.getElementById('prev-btn-desktop'),
                finish: document.getElementById('finish-btn'),
                finishDesktop: document.getElementById('finish-btn-desktop')
            };
            const canvas = document.getElementById('geometry-canvas');
            const ctx = canvas.getContext('2d');
            const stageTitle = document.getElementById('stage-title');
            const stageDescriptionContainer = document.getElementById('stage-description-container');
            const stageIndicator = document.getElementById('stage-indicator');
            const stageIndicatorDesktop = document.getElementById('stage-indicator-desktop');
            const canvasContainer = document.querySelector('.canvas-column');
            // Existing tiny snap sound placeholder (keeps behavior even if external MP3s aren't uploaded)
            const SNAP_SOUND = new Audio("data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=");

            // Audio manager: replace or add MP3 files in the `sounds/` folder next to this HTML file.
            // Expected filenames (you'll upload these):
            // - sounds/start.mp3       (played when activity starts)
            // - sounds/next.mp3        (played on next)
            // - sounds/prev.mp3        (played on prev)
            // - sounds/snap.mp3        (played when a piece snaps into place)
            // - sounds/success.mp3     (played when a stage completes)
            // - sounds/bgm.mp3         (optional background music)
            const SOUNDS = {
                start: null,
                next: null,
                prev: null,
                snap: null,
                success: null,
                bgm: null
            };

            function initSounds() {
                // create Audio objects but don't block if files are missing; errors are caught when played
                try { SOUNDS.start = new Audio('sounds/start.mp3'); } catch(e) { SOUNDS.start = null; }
                try { SOUNDS.next = new Audio('sounds/next.mp3'); } catch(e) { SOUNDS.next = null; }
                try { SOUNDS.prev = new Audio('sounds/prev.mp3'); } catch(e) { SOUNDS.prev = null; }
                try { SOUNDS.snap = new Audio('sounds/snap.mp3'); } catch(e) { SOUNDS.snap = null; }
                try { SOUNDS.success = new Audio('sounds/success.mp3'); } catch(e) { SOUNDS.success = null; }
                try { SOUNDS.bgm = new Audio('sounds/bgm.mp3'); SOUNDS.bgm.loop = true; SOUNDS.bgm.volume = 0.35; } catch(e) { SOUNDS.bgm = null; }
            }

            function playSound(name) {
                const s = SOUNDS[name];
                if (!s) return; // silent if not provided
                // attempt to play; modern browsers require user interaction before audio can play
                s.currentTime = 0;
                s.play().catch(err => {
                    // ignore play errors (autoplay policy) ‚Äî sound will play after user gesture
                    // console.log('sound play blocked', name, err);
                });
            }

            // Initialize audio placeholders (won't throw if files don't exist)
            initSounds();
            let currentStage = 0; const totalStages = 4; let shapes = [];
            let draggedShape = null, isAnimating = false; let dragOffsetX, dragOffsetY;

            // Compute the positive solution for x from the quadratic x^2 + 10x = 39
            const equation = { a: 1, b: 10, c: -39 };
            const discriminant = equation.b * equation.b - 4 * equation.a * equation.c;
            const roots = [(-equation.b + Math.sqrt(Math.max(0, discriminant))) / (2 * equation.a), (-equation.b - Math.sqrt(Math.max(0, discriminant))) / (2 * equation.a)];
            const xValue = Math.max(...roots); // take positive root (3)

            // Helper to compute unit (pixels per 1 unit length) and start positions so
            // unit-based layout (x, 5, 10, etc.) fits nicely inside the canvas.
            // global canvas offsets (pixels) to shift all canvas contents
            const CANVAS_Y_OFFSET = 20;
            const CANVAS_X_OFFSET = 30; // shifted all canvas contents 6px to the right

            function computeLayoutUnits(W, H) {
                // total geometric width in units: x (the square) + 10 (the 10x rectangle width)
                const totalUnitsWidth = xValue + 10; // units
                // leave horizontal padding of ~16% of canvas width to avoid touching edges
                const usableWidth = Math.max(40, W * 0.72);
                const unit = usableWidth / totalUnitsWidth;
                // center the figure horizontally
                const figureWidthPx = unit * totalUnitsWidth;
                const startX = Math.max(12, (W - figureWidthPx) / 2) + CANVAS_X_OFFSET;
                // apply a small top margin plus the configurable vertical offset
                const startY = Math.max(12, H * 0.14) + CANVAS_Y_OFFSET;
                return { unit, startX, startY };
            }

            const stageData = {
                1: { 
                    title: 'üéØ A≈üama 1: Par√ßalarƒ± Tanƒ±yalƒ±m', 
                    description: `
                        <p>Denklemimizdeki <code style="background: rgba(37, 99, 235, 0.1); padding: 2px 6px; border-radius: 4px; font-family: 'JetBrains Mono', monospace;"><strong>x</strong>¬≤</code> terimi bir kenarƒ± '<strong>x</strong>' olan mavi bir kareyle, <code style="background: rgba(22, 163, 74, 0.1); padding: 2px 6px; border-radius: 4px; font-family: 'JetBrains Mono', monospace;"><strong>10</strong><strong>x</strong></code> terimi ise kenarlarƒ± '<strong>10</strong>' ve '<strong>x</strong>' olan ye≈üil bir dikd√∂rtgenle temsil ediliyor.</p>
                        <div style="background: linear-gradient(145deg, #f0f9ff, #e0f2fe); border-radius: 8px; padding: 15px; margin: 1rem 0; border-left: 3px solid var(--primary-color);">
                            <p style="margin: 0; font-size: 0.9rem; color: var(--text-strong);">üí° Denklemimize g√∂re bu iki alanƒ±n toplamƒ± <strong>39</strong> birimkaredir.</p>
                        </div>
                        <p>"ƒ∞leri" butonuna basarak bu ≈üekilleri birle≈ütirip tam bir kare olu≈üturmaya ba≈ülayalƒ±m.</p>
                    ` 
                },
                2: { 
                    title: '‚öñÔ∏è A≈üama 2: Simetri i√ßin Hazƒ±rlƒ±k', 
                    description: `
                        <p>Amacƒ±mƒ±z bir kare olu≈üturmak olduƒüu i√ßin, <code style="background: rgba(22, 163, 74, 0.1); padding: 2px 6px; border-radius: 4px; font-family: 'JetBrains Mono', monospace;"><strong>10</strong><strong>x</strong></code>'lik dikd√∂rtgeni iki e≈ü <code style="background: rgba(22, 163, 74, 0.1); padding: 2px 6px; border-radius: 4px; font-family: 'JetBrains Mono', monospace;"><strong>5</strong><strong>x</strong></code> par√ßasƒ±na ayƒ±rarak karenin iki yanƒ±na simetrik olarak yerle≈ütireceƒüiz.</p>
                        <div style="background: linear-gradient(145deg, #f0fdf4, #dcfce7); border-radius: 8px; padding: 15px; margin: 1rem 0; border-left: 3px solid var(--success-color);">
                            <p style="margin: 0; font-size: 0.9rem; color: #166534;"><strong>üéØ G√∂revin:</strong> Ye≈üil par√ßalardan birini s√ºr√ºkleyerek mavi karenin altƒ±ndaki hedef alana yerle≈ütir.</p>
                        </div>
                    ` 
                },
                3: { 
                    title: 'üß© A≈üama 3: Kareyi Tamamlayalƒ±m!', 
                    description: `
                        <p>√áok g√ºzel! ≈ûekli tam bir kare yapabilmek i√ßin saƒü alt k√∂≈üede bir bo≈üluk olu≈ütuƒüunu fark ettin mi? Bu bo≈üluƒüun kenarlarƒ± <strong>5</strong>'e <strong>5</strong>, yani alanƒ± <strong>25 birimkaredir.</strong></p>
                        <div style="background: linear-gradient(145deg, #fef2f2, #fee2e2); border-radius: 8px; padding: 15px; margin: 1rem 0; border-left: 3px solid var(--danger-color);">
                            <p style="margin: 0; font-size: 0.9rem; color: #991b1b;"><strong>üéØ G√∂revin:</strong> Bu bo≈üluƒüu doldurmak i√ßin 25 birimkarelik kƒ±rmƒ±zƒ± kareyi yerine s√ºr√ºkle.</p>
                        </div>
                    ` 
                },
                4: { 
                    title: 'üéì A≈üama 4: √á√∂z√ºme Ula≈üalƒ±m', 
                    description: `
                        <p>Harika! Artƒ±k kenarlarƒ± <strong>(<strong>x</strong> + <strong>5</strong>)</strong> olan tam bir kare olu≈üturdun. Bu karenin toplam alanƒ± ise <code class="math-expression" style="font-family: 'JetBrains Mono', monospace;"><strong>39</strong> + <strong>25</strong> = <strong>64</strong></code> oldu. ≈ûimdi bu geometrik √ß√∂z√ºm√ºn cebirsel adƒ±mlarƒ±nƒ± inceleyelim:</p>
                        <div class="solution-steps">
                            x¬≤ + 10x + 25 = 39 + 25<br>
                            (x + 5)¬≤ = 64<br>
                            x + 5 = 8<br>
                            <strong>x = 3</strong> ‚ú®
                        </div>
                        <div class="historical-note">
                            <strong>üìö Tarihsel Not:</strong> Harezmi'nin d√∂neminde bir uzunluk negatif olamayacaƒüƒ± i√ßin denklemin yalnƒ±zca pozitif k√∂k√º dikkate alƒ±nƒ±rdƒ±. Bu nedenle Harezmi bu denklemin √ß√∂z√ºm√ºn√º <strong>x = 3</strong> olarak bulmu≈ütur.
                        </div>
                    `
                }
            };

            class Shape {
                 constructor(x, y, w, h, color, label = '', id = null) { this.id = id; this.x = x; this.y = y; this.w = w; this.h = h; this.color = color; this.label = label; this.draggable = false; this.isSnapped = false; this.target = null; }
                draw(context) { 
                    context.fillStyle = this.color; 
                    if (this === draggedShape) { context.globalAlpha = 0.7; } 
                    context.fillRect(this.x, this.y, this.w, this.h); 
                    context.globalAlpha = 1; 
                    context.strokeStyle = '#0f172a'; 
                    context.lineWidth = 2; 
                    context.strokeRect(this.x, this.y, this.w, this.h); 
                    if (this.label) { 
                        context.fillStyle = 'white'; 
                        context.font = `bold ${Math.min(this.w, this.h) * 0.25}px Inter, sans-serif`; 
                        context.textAlign = 'center'; 
                        context.textBaseline = 'middle'; 
                        context.fillText(this.label, this.x + this.w / 2, this.y + this.h / 2); 
                    } 
                }
                contains(mx, my) { return (mx >= this.x && mx <= this.x + this.w && my >= this.y && my <= this.y + this.h); }
            }
            function setupCanvas() { 
                const size = Math.min(canvasContainer.clientWidth, 500); 
                canvas.width = size; 
                canvas.height = size; 
                canvas.style.touchAction = 'none';
                canvas.style.userSelect = 'none';
                canvas.style.webkitUserSelect = 'none';
                canvas.style.cursor = 'grab';
            }
            // currentUnit is set by drawLabels each frame so helpers can size/offset consistently
            let currentUnit = 1;
            function drawDimensionLineSegment(x1, y1, x2, y2) {
                const tick = Math.max(4, Math.round(currentUnit * 0.3));
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                const isVertical = Math.abs(x1 - x2) < 0.5;
                if (isVertical) {
                    ctx.moveTo(x1 - tick, y1);
                    ctx.lineTo(x1 + tick, y1);
                    ctx.moveTo(x2 - tick, y2);
                    ctx.lineTo(x2 + tick, y2);
                } else {
                    ctx.moveTo(x1, y1 - tick);
                    ctx.lineTo(x1, y1 + tick);
                    ctx.moveTo(x2, y2 - tick);
                    ctx.lineTo(x2, y2 + tick);
                }
                ctx.strokeStyle = '#0f172a';
                ctx.lineWidth = 1.5;
                ctx.stroke();
            }

            function drawDimensionText(x, y, text, vertical = false, offset) {
                const offsetPx = (typeof offset === 'number') ? offset : Math.max(10, Math.round(currentUnit * 0.6));
                ctx.fillStyle = '#0f172a';
                // font size scales with unit but clamped for readability
                const fontSize = Math.max(12, Math.min(20, Math.round(currentUnit * 0.6 + 12)));
                ctx.font = `bold ${fontSize}px Inter, sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                if (vertical) {
                    const drawX = x - offsetPx; // place left of the vertical line
                    ctx.save();
                    ctx.translate(drawX, y);
                    ctx.rotate(-Math.PI / 2);
                    ctx.fillText(text, 0, 0);
                    ctx.restore();
                } else {
                    const drawY = y - offsetPx; // place above the horizontal line
                    ctx.fillText(text, x, drawY);
                }
            }
            function drawLabels() {
                const W = canvas.width, H = canvas.height;
                const layout = computeLayoutUnits(W, H);
                const unit = layout.unit;
                // set helpers' unit so tick sizes and offsets scale consistently
                currentUnit = unit;
                const xDim = unit * xValue, fiveDim = unit * 5;
                const startX = layout.startX, startY = layout.startY;
                if (currentStage >= 1 && currentStage < 4) { 
                    const totalWidth = (currentStage === 1) ? xDim + fiveDim * 2 : xDim + fiveDim; 
                    const yPos = startY + xDim + fiveDim + Math.max(12, Math.round(unit * 0.6)) + 30; 
                    // place the measurement line lower, and push its label 5px further away
                    drawDimensionLineSegment(startX, yPos, startX + totalWidth, yPos); 
                    const labelOffset = Math.max(10, Math.round(currentUnit * 0.6)) + 5;
                    drawDimensionText(startX + totalWidth / 2, yPos, 'Toplam Alan = 39', false, labelOffset); 
                } else if (currentStage === 4) { 
                    // explicit, well-spaced horizontal dimension lines (top: total x+5, mid: x and 5 split)
                    const topGap = Math.max(18, Math.round(unit * 1.6));
                    const midGap = Math.max(8, Math.round(unit * 0.8));
                    const horizTopY = startY - topGap - 10; // for 'x + 5' (moved up 5px)
                    const horizMidY = startY - midGap; // for 'x' and '5' separate lines

                    // vertical dimension lines to the left: inner shows x and 5 parts, outer shows total x+5
                    const vertInnerX = Math.max(12, startX - Math.max(16, Math.round(unit * 0.5)));
                    // widen spacing between inner and outer vertical lines by 2px (outer further left)
                    const vertOuterX = Math.max(12, startX - Math.max(32, Math.round(unit * 1.2)) - 16);

                    const smallOffset = Math.max(10, Math.round(unit * 0.7));

                    // mid lines: left 'x' and right '5' as two segments with a small gap/tick between
                    drawDimensionLineSegment(startX, horizMidY, startX + xDim, horizMidY);
                    drawDimensionLineSegment(startX + xDim, horizMidY, startX + xDim + fiveDim, horizMidY);
                    drawDimensionText(startX + xDim / 2, horizMidY, 'x', false, smallOffset);
                    drawDimensionText(startX + xDim + fiveDim / 2, horizMidY, '5', false, smallOffset);

                    // top overall line for x + 5
                    drawDimensionLineSegment(startX, horizTopY, startX + xDim + fiveDim, horizTopY);
                    drawDimensionText(startX + (xDim + fiveDim) / 2, horizTopY, 'x + 5', false, smallOffset + 4);

                    // vertical inner: mark x and 5 separately
                    drawDimensionLineSegment(vertInnerX, startY, vertInnerX, startY + xDim);
                    drawDimensionText(vertInnerX, startY + xDim / 2, 'x', true, smallOffset);
                    drawDimensionLineSegment(vertInnerX, startY + xDim, vertInnerX, startY + xDim + fiveDim);
                    drawDimensionText(vertInnerX, startY + xDim + fiveDim / 2, '5', true, smallOffset);

                    // vertical outer: full x + 5
                    drawDimensionLineSegment(vertOuterX, startY, vertOuterX, startY + xDim + fiveDim);
                    drawDimensionText(vertOuterX, startY + (xDim + fiveDim) / 2, 'x + 5', true, smallOffset + 4);
                    ctx.fillStyle = 'white'; 
                    ctx.strokeStyle = 'black'; 
                    ctx.lineWidth = 4; 
                    ctx.font = `bold ${Math.max(20, Math.min(40, unit * 3))}px Inter, sans-serif`;
                    ctx.textAlign = 'center'; 
                    ctx.textBaseline = 'middle'; 
                    const text = '39 + 25 = 64'; 
                    ctx.strokeText(text, W/2-30 + CANVAS_X_OFFSET - 25, H-100 + CANVAS_Y_OFFSET); 
                    ctx.fillText(text, W/2-30 + CANVAS_X_OFFSET - 25, H-100 + CANVAS_Y_OFFSET); 
                }
            }
            
            function render() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                shapes.forEach(s => { if (s.target && !s.isSnapped) { ctx.setLineDash([6, 6]); const isHovering = draggedShape === s && (s.x > s.target.x - s.w * 0.5 && s.x < s.target.x + s.target.w - s.w * 0.5 && s.y > s.target.y - s.h * 0.5 && s.y < s.target.y + s.target.h - s.h * 0.5); ctx.strokeStyle = isHovering ? 'rgba(22, 163, 74, 1)' : '#94a3b8'; ctx.fillStyle = isHovering ? 'rgba(22, 163, 74, 0.1)' : 'transparent'; ctx.lineWidth = 2; ctx.fillRect(s.target.x, s.target.y, s.target.w, s.target.h); ctx.strokeRect(s.target.x, s.target.y, s.target.w, s.target.h); ctx.setLineDash([]); } });
                shapes.forEach(s => s.draw(ctx));
                drawLabels();
            }

            function animate(updateFunc, duration) { let startTime = null; isAnimating = true; function step(timestamp) { if (!startTime) startTime = timestamp; const progress = Math.min((timestamp - startTime) / duration, 1); updateFunc(progress); render(); if (progress < 1) { requestAnimationFrame(step); } else { isAnimating = false; render(); } } requestAnimationFrame(step); }
            
            function updateButtonStates(stage) {
                [buttons.prev, buttons.prevDesktop].forEach(btn => { if(btn) btn.disabled = (stage === 1); });
                [buttons.next, buttons.nextDesktop].forEach(btn => { 
                    if(btn) {
                        btn.disabled = true;
                        if (stage === totalStages) {
                            btn.innerHTML = 'Tekrar Ba≈üla <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M20 12C20 16.4183 16.4183 20 12 20C7.58172 20 4 16.4183 4 12C4 7.58172 7.58172 4 12 4M12 4L12 2M12 4L14 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>';
                        } else {
                            btn.innerHTML = 'ƒ∞leri <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M9 18L15 12L9 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>';
                        }
                    }
                });
                // Bitir butonlarƒ±nƒ± sadece son a≈üamada g√∂ster
                const showFinish = (stage === totalStages);
                [buttons.finish, buttons.finishDesktop].forEach(btn => {
                    if (!btn) return;
                    btn.style.display = showFinish ? 'inline-flex' : 'none';
                });
                
                const fractionHtml = `<span>A≈üama<br><span class="stage-fraction">${stage} / ${totalStages}</span></span>`;
                if (stageIndicator) stageIndicator.innerHTML = fractionHtml;
                if (stageIndicatorDesktop) stageIndicatorDesktop.innerHTML = fractionHtml;
            }
            
            function enableNextButtons() {
                [buttons.next, buttons.nextDesktop].forEach(btn => { if(btn) btn.disabled = false; });
            }

            function transitionToStage(stage) {
                currentStage = stage;
                const data = stageData[stage];
                stageTitle.innerHTML = `${data.title} <span class="badge badge-part">${stage}/${totalStages}</span>`;
                stageDescriptionContainer.innerHTML = data.description;
                updateButtonStates(stage);
                
                document.getElementById('success-message').style.display = 'none';
                
                const W = canvas.width, H = canvas.height;
                const layout = computeLayoutUnits(W, H);
                const unit = layout.unit;
                const xDim = unit * xValue, fiveDim = unit * 5;
                const startX = layout.startX, startY = layout.startY;

                if (stage === 1) {
                    shapes = [
                        new Shape(startX, startY, xDim, xDim, 'rgba(37, 99, 235, 0.8)', 'x¬≤', 'x_square'), 
                        new Shape(startX + xDim, startY, fiveDim * 2, xDim, 'rgba(22, 163, 74, 0.8)', '10x', '10x_rect')
                    ];
                    enableNextButtons(); 
                    render();
                } else if (stage === 2) {
                    const rect10x = shapes.find(s => s.id === '10x_rect');
                    const initialX = rect10x.x;
                    shapes = shapes.filter(s => s.id !== '10x_rect');
                    const rect1 = new Shape(initialX, startY, fiveDim, xDim, 'rgba(22, 163, 74, 0.8)', '5x', '5x_rect1');
                    const rect2 = new Shape(initialX + fiveDim, startY, fiveDim, xDim, 'rgba(22, 163, 74, 0.8)', '5x', '5x_rect2');
                    shapes.push(rect1, rect2);
                    animate(p => { 
                        const ease = 1 - Math.pow(1 - p, 3); 
                        const gap = 12;
                        rect1.x = initialX + (startX + xDim - initialX) * ease; 
                        rect2.x = (initialX + fiveDim) + gap * ease; 
                        const rightPad = Math.max(8, W * 0.02);
                        rect2.x = Math.min(rect2.x, W - fiveDim - rightPad);
                        rect2.x = Math.max(rect2.x, rect1.x + rect1.w + 6);
                    }, 800);
                    setTimeout(() => { 
                        rect2.draggable = true; 
                        rect2.target = { x: startX, y: startY + xDim, w: xDim, h: fiveDim }; 
                        render(); 
                    }, 800);
                } else if (stage === 3) {
                    const gapX = startX + xDim;
                    const gapY = startY + xDim;
                    const gapW = fiveDim;
                    const figureRightEdge = startX + xDim + fiveDim;
                    const margin = Math.max(8, W * 0.015);
                    let spawnX = figureRightEdge + margin;
                    let spawnY = gapY;
                    const rightPad = Math.max(4, W * 0.008);
                    spawnX = Math.min(spawnX, W - fiveDim - rightPad);
                    
                    if (spawnX <= figureRightEdge + Math.max(4, W * 0.008)) {
                        spawnX = gapX + gapW / 2 - fiveDim / 2;
                        spawnY = gapY - fiveDim - Math.max(15, H * 0.03);
                        spawnX = Math.max(Math.max(4, W * 0.008), Math.min(spawnX, W - fiveDim - rightPad));
                        spawnY = Math.max(Math.max(8, H * 0.02), spawnY);
                    }

                    const finalPiece = new Shape(spawnX, spawnY, fiveDim, fiveDim, 'rgba(220, 38, 38, 0.8)', '25', '25_square');
                    finalPiece.draggable = true; 
                    finalPiece.target = { x: gapX, y: gapY, w: fiveDim, h: fiveDim };
                    shapes.push(finalPiece); 
                    render();
                } else if (stage === 4) {
                    shapes.forEach(s => s.label = '');
                    enableNextButtons();
                    render();
                }
            }
            function snapShape(shape) { 
                if (!shape || isAnimating) return; 
                const startX = shape.x, startY = shape.y; 
                const target = shape.target; 
                draggedShape = null; 
                canvas.style.cursor = 'default'; 
                
                const successMsg = document.getElementById('success-message');
                successMsg.style.display = 'block';
                
                // play small snap effect (both data-uri fallback and user-provided snap.mp3)
                SNAP_SOUND.play().catch(e => { }); 
                playSound('snap');
                animate(p => { 
                    const ease = 1 - Math.pow(1 - p, 4); 
                    shape.x = startX + (target.x - startX) * ease; 
                    shape.y = startY + (target.y - startY) * ease; 
                }, 300); 
                setTimeout(() => { 
                    shape.isSnapped = true; 
                    shape.draggable = false; 
                    if (shape.id === '5x_rect2') { 
                        shape.w = shape.target.w; 
                        shape.h = shape.target.h; 
                    } 
                    // success music/feedback when the piece has settled
                    playSound('success');
                    setTimeout(() => {
                        successMsg.style.display = 'none';
                        transitionToStage(currentStage + 1); 
                    }, 1500);
                }, 300); 
            }
            function handleMouseDown(e) { if (isAnimating) return; const { x, y } = getMousePos(e); for (let i = shapes.length - 1; i >= 0; i--) { if (shapes[i].draggable && !shapes[i].isSnapped && shapes[i].contains(x, y)) { draggedShape = shapes[i]; dragOffsetX = x - draggedShape.x; dragOffsetY = y - draggedShape.y; canvas.style.cursor = 'grabbing'; return; } } }
            function handleMouseMove(e) { if (!draggedShape) return; const { x, y } = getMousePos(e); draggedShape.x = x - dragOffsetX; draggedShape.y = y - dragOffsetY; const target = draggedShape.target; const isInside = (draggedShape.x > target.x - draggedShape.w * 0.5 && draggedShape.x < target.x + target.w - draggedShape.w * 0.5 && draggedShape.y > target.y - draggedShape.h * 0.5 && draggedShape.y < target.y + target.h - draggedShape.h * 0.5); if (isInside) { snapShape(draggedShape); } else { render(); } }
            function handleMouseUp(e) { if (!draggedShape) return; draggedShape = null; canvas.style.cursor = 'grab'; render(); }
            function getMousePos(e) { 
                const rect = canvas.getBoundingClientRect(); 
                let clientX, clientY;
                if (e.touches && e.touches.length > 0) { clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; } 
                else if (e.changedTouches && e.changedTouches.length > 0) { clientX = e.changedTouches[0].clientX; clientY = e.changedTouches[0].clientY; } 
                else { clientX = e.clientX; clientY = e.clientY; }
                return { x: (clientX - rect.left) * (canvas.width / rect.width), y: (clientY - rect.top) * (canvas.height / rect.height) }; 
            }

            function handleNextClick() {
                if (isAnimating) return;
                playSound('next');
                if (currentStage === totalStages) {
                    shapes = [];
                    transitionToStage(1);
                } else {
                    transitionToStage(currentStage + 1);
                }
            }
            
            function handlePrevClick() {
                if (!isAnimating && currentStage > 1) { 
                    playSound('prev');
                    // Go back to stage 1 from any stage
                    transitionToStage(1); 
                }
            }

            function handleFinishClick() {
                // Etkinliƒüi tamamla: intro ekranƒ±na d√∂n, sesleri durdur ve durumu sƒ±fƒ±rla
                if (SOUNDS.bgm) { try { SOUNDS.bgm.pause(); SOUNDS.bgm.currentTime = 0; } catch(e) {} }
                shapes = [];
                showScreen('intro');
                currentStage = 0;
                // Bitir sonrasƒ± butonlarƒ± gizli tutmak i√ßin g√ºvenlik
                if (buttons.finish) buttons.finish.style.display = 'none';
                if (buttons.finishDesktop) buttons.finishDesktop.style.display = 'none';
                // Pencereyi √ºste kaydƒ±r
                try { window.scrollTo({ top: 0, behavior: 'smooth' }); } catch(e) { window.scrollTo(0, 0); }
            }

            buttons.start.addEventListener('click', () => { 
                showScreen('activity'); 
                setupCanvas(); 
                transitionToStage(1); 
                playSound('start');
                if (SOUNDS.bgm) { SOUNDS.bgm.play().catch(()=>{}); }
            });
            
            buttons.next.addEventListener('click', handleNextClick);
            buttons.prev.addEventListener('click', handlePrevClick);
            
            buttons.nextDesktop.addEventListener('click', handleNextClick);
            buttons.prevDesktop.addEventListener('click', handlePrevClick);
            if (buttons.finish) buttons.finish.addEventListener('click', handleFinishClick);
            if (buttons.finishDesktop) buttons.finishDesktop.addEventListener('click', handleFinishClick);
            
            function showScreen(screenName) { Object.values(screens).forEach(s => s.style.display = 'none'); screens[screenName].style.display = 'block'; }
            
            canvas.addEventListener('mousedown', handleMouseDown); 
            canvas.addEventListener('mousemove', handleMouseMove); 
            canvas.addEventListener('mouseup', handleMouseUp); 
            canvas.addEventListener('mouseleave', handleMouseUp);
            
            canvas.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); handleMouseDown(e); }, { passive: false }); 
            canvas.addEventListener('touchmove', (e) => { e.preventDefault(); e.stopPropagation(); handleMouseMove(e); }, { passive: false }); 
            canvas.addEventListener('touchend', (e) => { e.preventDefault(); e.stopPropagation(); handleMouseUp(e); }, { passive: false });
            canvas.addEventListener('touchcancel', (e) => { e.preventDefault(); handleMouseUp(e); }, { passive: false });
        });
    </script>
</body>
</html>